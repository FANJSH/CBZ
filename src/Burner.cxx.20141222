#include <cstdlib>
#include "Burner.h"

Burner::Burner()
{
  med.resize(3);
  sub_step_org=20; 
  up_scattering=false;
  input_flux_level=false;
  adj_nuc_data=false;
  hm_weight_init=0.;

  burn_time_calc=false;

  limit_burnup=false;
  bumax=0.;

  matrix_extract=false;
  mat_ext_filename="";

  cooling_cal=false;
};

void Burner::PutGroup(int i)
{
  group=i;

  for(int i=0;i<3;i++){
    med[i].PutImax(group);
    med[i].PutPL(1);
  };
};

void Burner::PutFuelData(FRDTFuelComposition &fcom,real temp)
{
  int num=0;
  for(int i=0;i<fcom.GetNucnum();i++){
    real den=fcom.GetDensity(i);
    if(den>0.)num++;
  };

  int *mat=new int[num];
  real *den=new real[num];

  num=0;
  for(int i=0;i<fcom.GetNucnum();i++){
    real deninp=fcom.GetDensity(i);
    if(deninp>0.){
      mat[num]=fcom.GetNucid(i);
      den[num]=deninp;
      num++;
    };
  };

  PutFuelData(num,mat,den,temp);

  delete [] mat;
  delete [] den;
};

void Burner::PutFuelData(int nuc,int *mat,real *den,real temp)
{
  cout<<"#\n# Fuel number density information\n#\n";
  med[0].NuclideClear();
  for(int i=0;i<nuc;i++){
    if(mat[i]<=9999)mat[i]=midt.GetMATIDFromENDFID(mat[i]);
    Nuclide nucinp;
    nucinp.PutMatnum(mat[i]);
    if(den[i]>0.1){
      cout<<"# Error(?) in Burner::PutFuelData.\n";
      cout<<"# Too large values for number density : "<<den[i]<<"\n";
      cout<<"# Material ID is "<<mat[i]<<"\n";
      exit(0);
    };
    if(den[i]<0.){
      cout<<"# Error in Burner::PutFuelData.\n";
      cout<<"# Negative number density is detected.\n";
      cout<<"# Material ID is "<<mat[i]<<"\n";
      exit(0);
    };
    nucinp.PutDensity(den[i]);
    nucinp.PutTemperature(temp);
    cout<<"#    "<<midt.Name(mat[i])<<" : "<<den[i]<<"\n";
    med[0].AddNuclide(nucinp);
  };
  cout<<"#\n";
};

void Burner::PutCladData(int nuc,int *mat,real *den,real temp)
{
  for(int i=0;i<nuc;i++){
    if(mat[i]<=9999)mat[i]=midt.GetMATIDFromENDFID(mat[i]);
  };
  med[1].PutNuclide(nuc,mat,den);
  med[1].PutTemperatureForAllNuclide(temp);
};

void Burner::PutModeratorData(int nuc,int *mat,real *den,real temp)
{
  for(int i=0;i<nuc;i++){
    if(mat[i]<=9999)mat[i]=midt.GetMATIDFromENDFID(mat[i]);
  };
  med[2].PutNuclide(nuc,mat,den);
  med[2].PutTemperatureForAllNuclide(temp);
};

void Burner::PutGeometryData(real pitch,int ring,real *rri,int *rmedi)
{
  mesh=ring+1;
  vector<real> rr(ring);

  mesh_fuel=0;
  mesh_clad=0;
  for(int i=0;i<ring;i++){
    if(rmedi[i]==0)mesh_fuel++;
    if(rmedi[i]==1)mesh_clad++;
  };

  region_medium=new int[mesh];
  fuel_r=0.;
  clad_r=0.;
  for(int i=0;i<ring;i++){
    region_medium[i]=rmedi[i];
    rr[ring-1-i]=rri[i];
    if(rmedi[i]==1&&fuel_r==0.){
      fuel_r=rri[i-1];
    };
    if(rmedi[i]==2&&clad_r==0.)clad_r=rri[i-1];
  };
  if(clad_r==0.)clad_r=rri[ring-1];
  region_medium[ring]=2;

  real pin_pitch=pitch;
  fuel_vol=fuel_r*fuel_r*PI;
  clad_vol=clad_r*clad_r*PI-fuel_vol;
  mod_vol=pitch*pitch-fuel_vol-clad_vol;

  // +++ boundary condition
  enum BCondition bc_ssc=Periodic;  // (self-shielding calculation)
  enum BCondition bc_flx=Periodic;  // (eigenvalue calculation)

  // +++ IGI for self-shielding calculation
  IrregularGeometryInformation igi;
  GeomPolygon pol;
  pol.PutRectangular(0.,0.,pin_pitch*0.5,pin_pitch*0.5);
  pol.PutRegionID(2);
  igi.AddGeom(pol);
  GeomCircle cir1(0.,0.,clad_r);
  cir1.PutRegionID(1);
  igi.AddGeom(cir1);
  GeomCircle cir2(0.,0.,fuel_r);
  cir2.PutRegionID(0);
  igi.AddGeom(cir2);

  sys.PutBoundaryCondition(bc_ssc);
  sys.CalTrajectory(igi,8,0.02,45.);

  // +++ IGI for flux calculation
  IrregularGeometryInformation igi_f;
  GeomPolygon pol2;
  pol2.PutRectangular(0.,0.,pin_pitch*0.5,pin_pitch*0.5);
  pol2.PutRegionID(mesh-1);
  igi_f.AddGeom(pol2);
  int *rid=new int[ring];
  for(int i=0;i<ring;i++){
    rid[i]=ring-1-i;
  };
  igi_f.AddCircleRing(ring,rr,rid);
  delete [] rid;

  sys_f.PutBoundaryCondition(bc_flx);
  sys_f.CalTrajectory(igi_f,8,0.02,45.);

  igi_f.WriteGnuplotFile(0.001);
};

void Burner::PutGeometryDataCylinder(real pitch,int ring,real *rri,int *rmedi)
{
  mesh=ring+1;
  vector<real> rr(ring);

  mesh_fuel=0;
  mesh_clad=0;
  for(int i=0;i<ring;i++){
    if(rmedi[i]==0)mesh_fuel++;
    if(rmedi[i]==1)mesh_clad++;
  };

  region_medium=new int[mesh];
  fuel_r=0.;
  clad_r=0.;
  for(int i=0;i<ring;i++){
    region_medium[i]=rmedi[i];
    rr[ring-1-i]=rri[i];
    if(rmedi[i]==1&&fuel_r==0.){
      fuel_r=rri[i-1];
    };
    if(rmedi[i]==2&&clad_r==0.)clad_r=rri[i-1];
  };
  if(clad_r==0.)clad_r=rri[ring-1];
  region_medium[ring]=2;

  real pin_pitch=pitch;
  fuel_vol=fuel_r*fuel_r*PI;
  clad_vol=clad_r*clad_r*PI-fuel_vol;

  real outr=sqrt(pin_pitch*pin_pitch/PI);

  // +++ boundary condition
  enum BCondition bc_ssc=White;     // (self-shielding calculation)
  enum BCondition bc_flx=White;  // (eigenvalue calculation)

  // +++ IGI for self-shielding calculation
  IrregularGeometryInformation igi;
  GeomCircle pol(0.,0.,outr);
  pol.PutRegionID(2);
  igi.AddGeom(pol);
  GeomCircle cir1(0.,0.,clad_r);
  cir1.PutRegionID(1);
  igi.AddGeom(cir1);
  GeomCircle cir2(0.,0.,fuel_r);
  cir2.PutRegionID(0);
  igi.AddGeom(cir2);

  sys.PutBoundaryCondition(bc_ssc);
  sys.CalTrajectory(igi,1,0.02,45.);

  // +++ IGI for flux calculation
  IrregularGeometryInformation igi_f;
  GeomCircle pol2(0.,0.,outr);
  pol2.PutRegionID(mesh-1);
  igi_f.AddGeom(pol2);
  int *rid=new int[ring];
  for(int i=0;i<ring;i++){
    rid[i]=ring-1-i;
  };
  igi_f.AddCircleRing(ring,rr,rid);
  delete [] rid;

  sys_f.PutBoundaryCondition(bc_flx);
  sys_f.CalTrajectory(igi_f,1,0.02,45.);

  igi_f.WriteGnuplotFile(0.001);
};

void Burner::PutThreeRegionCircularGeometry(real *rri)
{
  mesh=3;

  region_medium=new int[mesh];
  for(int i=0;i<3;i++){
    region_medium[i]=i;
  };

  fuel_r=rri[0];
  clad_r=rri[1];
  mesh_fuel=1;
  mesh_clad=1;

  fuel_vol=fuel_r*fuel_r*PI;
  clad_vol=clad_r*clad_r*PI-fuel_vol;

  // +++ boundary condition
  enum BCondition bc_ssc=Periodic;     // (self-shielding calculation)
  enum BCondition bc_flx=Periodic;  // (eigenvalue calculation)

  // +++ IGI for self-shielding calculation
  IrregularGeometryInformation igi;
  GeomCircle cir1(0.,0.,rri[2]);
  cir1.PutRegionID(2);
  GeomCircle cir2(0.,0.,clad_r);
  cir2.PutRegionID(1);
  GeomCircle cir3(0.,0.,fuel_r);
  cir3.PutRegionID(0);
  igi.AddGeom(cir1);
  igi.AddGeom(cir2);
  igi.AddGeom(cir3);

  sys.PutBoundaryCondition(bc_ssc);
  sys.CalTrajectory(igi,1,0.01,45.);

  sys_f.PutBoundaryCondition(bc_flx);
  sys_f.CalTrajectory(igi,1,0.01,45.);
};

void Burner::PutThreeRegionHexagonalGeometry(real pitch,real *rri)
{
  mesh=3;

  region_medium=new int[mesh];
  for(int i=0;i<3;i++){
    region_medium[i]=i;
  };

  fuel_r=rri[0];
  clad_r=rri[1];
  mesh_fuel=1;
  mesh_clad=1;

  fuel_vol=fuel_r*fuel_r*PI;
  clad_vol=clad_r*clad_r*PI-fuel_vol;

  // +++ boundary condition
  enum BCondition bc_ssc=Periodic;     // (self-shielding calculation)
  enum BCondition bc_flx=Periodic;  // (eigenvalue calculation)

  // +++ IGI for self-shielding calculation

  IrregularGeometryInformation igi;
  real bar=pitch/sqrt(3.);
  GeomPolygon hex;
  hex.PutHexagon(0.,0.,bar);
  hex.PutRegionID(2);
  GeomCircle cir2(0.,0.,clad_r);
  cir2.PutRegionID(1);
  GeomCircle cir3(0.,0.,fuel_r);
  cir3.PutRegionID(0);
  igi.AddGeom(hex);
  igi.AddGeom(cir2);
  igi.AddGeom(cir3);

  sys.PutBoundaryCondition(bc_ssc);
  sys.CalTrajectory(igi,12,0.01,60.);

  sys_f.PutBoundaryCondition(bc_flx);
  sys_f.CalTrajectory(igi,12,0.01,60.);
};

void Burner::PutWhiteBoundary()
{
  sys.PutBoundaryCondition(White);
  sys_f.PutBoundaryCondition(White);
};

void Burner::PutBurnStep(int i)
{
  burn_step=i;

  power_density_list.resize(burn_step);
  flux_level_list.resize(burn_step);
  burn_time.resize(burn_step);
  burn_time_gwd.resize(burn_step);
  sub_step_list.resize(burn_step+1);
  keff.resize(burn_step+1);
  //acday.resize(burn_step+1);
  //acburn.resize(burn_step+1);

  for(int i=0;i<burn_step;i++){
    sub_step_list[i]=sub_step_org;
  };

};

void Burner::PutPowerDensityList(real *inp,string type)
{
  for(int i=0;i<burn_step;i++){
    power_density_list[i]=inp[i];
  };

  for(int i=0;i<burn_step;i++){
    if(power_density_list[i]<1e-5){
      power_density_list[i]=0.;
    };
  };

  if(type=="W_cm"||type=="MW_t"){
    input_power_unit=type;
  }else{
    cout<<"# Error in Burner::PutPowerDensityList.\n";
    cout<<"# Unit ("<<type<<") is inappropriate.\n";
    exit(0);
  };
};

void Burner::PutFluxLevelList(real *inp)
{
  input_flux_level=true;
  for(int i=0;i<burn_step;i++){
    flux_level_list[i]=inp[i];
  };

  for(int i=0;i<burn_step;i++){
    sub_step_list[i]=sub_step_org;
  };
};

void Burner::PutBurnTime(real *inp,bool GWd_t,bool accumulate)
{
  burn_time_calc=false;

  for(int i=0;i<burn_step;i++){
    burn_time[i]=inp[i];
  };
  burn_time_GWd_t=GWd_t;
  burn_time_accumulate=accumulate;
};

void Burner::PutBurnTime(real inp,bool GWd_t,bool accumulate)
{
  real *inp2=new real[burn_step];
  for(int i=0;i<burn_step;i++){
    inp2[i]=inp;
  };
  PutBurnTime(inp2,GWd_t,accumulate);
  delete [] inp2;
};

GroupData2D Burner::GetTransitionMatrix(Burnup &bu)
{
  int sz=total_flux.size();
  return bu.CalTransitionMatrix(total_flux[sz-1][0],true);
};

void Burner::SetLibrary(string cbglibdir,string lib,int fp_num,string *fp_nuc)
{
  up_scattering=true;
  PutGroup(107);

  string libdir=cbglibdir;
  if(lib=="jendl-3.3"){
    libdir=libdir+"CBGLIB/j33.107g.iwt7/";
  }else if(lib=="jendl-4.0"){
    libdir=libdir+"CBGLIB/j4.107g.iwt7/";
  }else if(lib=="endf-7.1"){
    libdir=libdir+"CBGLIB/e71.107g.iwt7/";
  }else if(lib=="jeff-3.1.1"){
    libdir=libdir+"CBGLIB/jf311.107g.iwt7/";
  }else if(lib=="jeff-3.2"){
    libdir=libdir+"CBGLIB/jf32.107g.iwt7/";
  }else{
    cout<<"# Error in Burner::SetLibrary.\n";
    cout<<"# Library "<<lib<<" does not exist.\n";
    exit(0);
  };

  xslib.Initialize(libdir,"N-ENERGY");
  string filename_hm[]={
    // (Heavy nuclides : 21 nuclides)
    //"U234.T2","U235.U8","U236.U8","U237","U238.mix",
    "U234.T2","U235.U8","U236.T2","U237","U238.mix",
    "Np237","Np239","Pu238.U8","Pu239.mix","Pu240.mix",
    "Pu241.mix","Pu242.mix","Am241.mix","Am242","Am242m",
    "Am243.U8","Cm242","Cm243","Cm244.U8","Cm245",
    "Cm246",
  };
  string filename_str[]={
    // (light or medium-heavy nuclides : 11 nuclides)
    "O016","Zr000","H001","B010","Fe000",
    "Cr000","Ni000","B011","Co059","Mn055",
    "C000",
  };

  xslib.ReadFile(21,libdir,filename_hm);
  xslib.ReadFile(fp_num,libdir,fp_nuc);
  xslib.ReadFile(11,libdir,filename_str);

  // (thermal data)
  string libth=libdir;
  libth.append("Thermal/");
  xslib.GetLibData(10010).GetThScat().ReadFile(libth,"H.H2O");
  xslib.GetLibData(80160).GetThScat().ReadFile(libth,"O");

  // (Bell factor-optimization)
  string belldir=cbglibdir+"CBGLIB/Bell-107g/";
  xslib.ReadBellFactor(belldir,"U235.300K",922350);
  xslib.ReadBellFactor(belldir,"U238.300K",922380);
  xslib.ReadBellFactor(belldir,"Pu239.300K",942390);
  xslib.ReadBellFactor(belldir,"Pu240.300K",942400);
  xslib.ReadBellFactor(belldir,"Pu241.300K",942410);
  xslib.ReadBellFactor(belldir,"Pu242.300K",942420);

  // +++ multiple R-perameter for Cm-244 and U-238 / Cm-244 and Pu-239.
  XSLibrary xslib2;
  xslib2.Initialize(libdir,"N-ENERGY");
  string fname[]={"Cm244.P9"};
  xslib2.ReadFile(1,libdir,fname);
  xslib.GetLibData(962440).GetFtable().AddData(xslib2.GetLibData(962440).GetFtable(),56);
};

void Burner::SetLibraryFP103(string cbglibdir,string lib)
{
  int fp_num=98;
  string filename_fp[]={
    // (Fission products : 98 nuclides)
    "Kr083","Kr085","Sr090","Y090","Zr093",
    "Zr095","Zr096","Nb095","Mo095","Mo097",
    "Mo098","Mo099","Mo100","Tc099.U8","Ru100",
    "Ru101","Ru102","Ru103","Ru104","Ru105",
    "Ru106","Rh103","Rh105","Ag109.T2","Pd104",
    "Pd105","Pd106","Pd107","Pd108.T2","Cd110",
    "Cd111","Cd112","Cd113","Cd114","Cd116",
    "Ag107","In115","Sn126","Sb125","Sb126",
    "Te127m","I127","I129","I131","I135",
    "Xe131.T2","Xe132","Xe133","Xe134","Xe135",

    "Xe136","La139","La140","Cs133.T2","Cs134",
    "Cs135","Cs137","Ce140","Ce141","Ce144",
    "Ba137","Ba138","Ba140","Pr141","Pr143",
    "Nd142","Nd143","Nd144","Nd145","Nd146",
    "Nd147","Nd148","Nd150","Pm147","Pm148",
    "Pm149","Pm151","Sm147","Sm148","Sm149",
    "Sm150.T2","Sm151.U8","Sm152.U8","Eu151","Eu152",
    "Eu153.T2","Eu154","Eu155","Eu156","Eu157",
    "Gd152","Gd154","Gd155","Gd156","Gd157",
    "Gd158","Gd160","Pm148m",
  };
  SetLibrary(cbglibdir,lib,fp_num,filename_fp);
};

void Burner::SetLibraryFP103_70g(string cbglibdir)
{
  up_scattering=false;
  PutGroup(70);

  string libdir=cbglibdir+"CBGLIB/j4.70g.iwt7/";
  string libdir2=cbglibdir+"CBGLIB/tdl11.70g.iwt7/";
  xslib.Initialize(libdir,"N-ENERGY");
  string filename_hm[]={
    // (Heavy nuclides : 21 nuclides)
    "U234","U235","U236","U237","U238",
    "Np237","Np239","Pu238","Pu239","Pu240",
    "Pu241","Pu242","Am241","Am242","Am242m",
    "Am243","Cm242","Cm243","Cm244","Cm245",
    "Cm246",
  };
  string filename_fp[]={
    // (Fission products : 98 nuclides)
    "Kr083","Kr085","Sr090","Y090","Zr093",
    "Zr095","Zr096","Nb095","Mo095","Mo097",
    "Mo098","Mo099","Mo100","Tc099","Ru100",
    "Ru101","Ru102","Ru103","Ru104","Ru105",
    "Ru106","Rh103","Rh105","Ag109","Pd104",
    "Pd105","Pd106","Pd107","Pd108","Cd110",
    "Cd111","Cd112","Cd113","Cd114","Cd116",
    "Ag107","In115","Sn126","Sb125","Sb126",
    "Te127m","I127","I129","I131","I135",
    "Xe131","Xe132","Xe133","Xe134","Xe135",

    "Xe136","La139","La140","Cs133","Cs134",
    "Cs135","Cs137","Ce140","Ce141","Ce144",
    "Ba137","Ba138","Ba140","Pr141","Pr143",
    "Nd142","Nd143","Nd144","Nd145","Nd146",
    "Nd147","Nd148","Nd150","Pm147","Pm148",
    "Pm149","Pm151","Sm147","Sm148","Sm149",
    "Sm150","Sm151","Sm152","Eu151","Eu152",
    "Eu153","Eu154","Eu155","Eu156","Eu157",
    "Gd152","Gd154","Gd155","Gd156","Gd157",
    "Gd158","Gd160","Pm148m",
  };
  string filename_fp2[]={
    "Nb093m","Rh106","Sb126m","Ba137m","Pr144"
  };
  string filename_str[]={
    // (light or medium-heavy nuclides : 8 nuclides)
    "O016","Zr000","H001","B010","Fe000",
    "Cr000","Ni000","B011","Na023","Mn055",
    "Mo000","Co059"
  };

  xslib.ReadFile(21,libdir,filename_hm);
  xslib.ReadFile(98,libdir,filename_fp);
  xslib.ReadFile(5,libdir2,filename_fp2);
  xslib.ReadFile(12,libdir,filename_str);
};

void Burner::SetLibraryForThorium(string cbglibdir,string lib)
{
  SetLibrary(cbglibdir,lib);

  int nn=7;
  string filename[]={"Th232T","Pa231","Pa233","U232","U233T","Np236","Pu236"};

  string libdir=cbglibdir;
  if(lib=="jendl-3.3"){
    libdir=libdir+"CBGLIB/j33.107g.iwt7/";
  }else if(lib=="jendl-4.0"){
    libdir=libdir+"CBGLIB/j4.107g.iwt7/";
  }else if(lib=="endf-7.1"){
    libdir=libdir+"CBGLIB/e71.107g.iwt7/";
  }else if(lib=="jeff-3.1.1"){
    libdir=libdir+"CBGLIB/jf311.107g.iwt7/";
  }else{
    cout<<"# Error in Burner::SetLibrary.\n";
    cout<<"# Library "<<lib<<" does not exist.\n";
    exit(0);
  };

  xslib.ReadFile(nn,libdir,filename);  
};

void Burner::SetLibrary(string cbglibdir,string lib)
{
  int fp_num=185+1;
  string filename_fp[]={
    // (Fission products : 185+1 nuclides)
    "Ge073","Ge074","Ge076","As075","Se076",
    "Se077","Se078","Se079","Se080","Se082",
    "Br081","Kr082","Kr083","Kr084","Kr085",
    "Kr086","Rb085","Rb086","Rb087","Sr086",
    "Sr087","Sr088","Sr089","Sr090","Y089",
    "Y090","Y091","Zr090","Zr091","Zr092",
    "Zr093","Zr094","Zr095","Zr096","Nb093",
    "Nb094","Nb095","Mo092","Mo094","Mo095",
    "Mo096","Mo097","Mo098","Mo099","Mo100",
    "Tc099.U8","Ru100","Ru101","Ru102","Ru103",
    "Ru104","Ru105","Ru106","Rh103","Rh105",
    "Pd104","Pd105","Pd106","Pd107","Pd108.T2",
    "Pd110","Ag107","Ag109.T2","Ag110m","Cd110",
    "Cd111","Cd112","Cd113","Cd114","Cd116",
    "In113","In115","Sn116","Sn117","Sn118",
    "Sn119","Sn120","Sn122","Sn123","Sn124",
    "Sn126","Sb121","Sb123","Sb124","Sb125",
    "Sb126","Te122","Te123","Te124","Te125",
    "Te126","Te127m","Te128","Te129m","Te130",
    "Te132","I127","I129","I130","I131",
    "I135","Xe126","Xe128","Xe129","Xe130",
    "Xe131.T2","Xe132","Xe133","Xe134","Xe135",
    "Xe136","Cs133.T2","Cs134","Cs135","Cs136",
    "Cs137","Ba134","Ba135","Ba136","Ba137",
    "Ba138","Ba140","La139","La140","Ce140",
    "Ce141","Ce142","Ce143","Ce144","Pr141",
    "Pr143","Nd142","Nd143","Nd144","Nd145",
    "Nd146","Nd147","Nd148","Nd150","Pm147",
    "Pm148","Pm148m","Pm149","Pm151","Sm147",
    //"Sm148","Sm149","Sm150.U8","Sm151.U8","Sm152.U8",
    "Sm148","Sm149","Sm150.T2","Sm151.U8","Sm152.U8",
    "Sm153","Sm154","Eu151","Eu152","Eu153.T2",
    "Eu154","Eu155","Eu156","Eu157","Gd152",
    "Gd154","Gd155","Gd156","Gd157","Gd158",
    "Gd160","Tb159","Tb160","Dy160","Dy161",
    "Dy162","Dy163","Dy164","Ho165","Er162",
    "Er164","Er166","Er167","Er168","Er170",
    "Hf176","Hf177","Hf178","Hf179","Hf180",
    "Gd153",
  };
  SetLibrary(cbglibdir,lib,fp_num,filename_fp);
};

void Burner::SetLibraryAll(string cbglibdir,string lib)
{
  int fp_num=223;
  string filename_fp[]={
    // (Fission products : 223 nuclides)
    "Zn064","Zn066","Zn067","Zn068","Zn070",
    "Ga069","Ga071",
    "Ge070","Ge072","Ge073","Ge074","Ge076",
    "As075",
    "Se074","Se076","Se077","Se078","Se079","Se080","Se082",
    "Br079","Br081",
    "Kr078","Kr080","Kr082","Kr083","Kr084","Kr085","Kr086",
    "Rb085","Rb086","Rb087",
    "Sr084","Sr086","Sr087","Sr088","Sr089","Sr090",
    "Y089","Y090","Y091",
    "Zr090","Zr091","Zr092","Zr093","Zr094","Zr095","Zr096",
    "Nb093","Nb094","Nb095",
    "Mo092","Mo094","Mo095","Mo096","Mo097","Mo098","Mo099","Mo100",
    "Tc099.U8",
    "Ru096","Ru098","Ru099","Ru100","Ru101","Ru102","Ru103","Ru104","Ru105","Ru106",
    "Rh103","Rh105",
    "Pd102","Pd104","Pd105","Pd106","Pd107","Pd108.T2","Pd110",
    "Ag107","Ag109.T2","Ag110m","Ag111",
    "Cd106","Cd108","Cd110","Cd111","Cd112","Cd113","Cd114","Cd116",
    "In113","In115",
    "Sn112","Sn114","Sn115","Sn116","Sn117","Sn118","Sn119","Sn120","Sn122","Sn123","Sn124","Sn126",
    "Sb121","Sb123","Sb124","Sb125","Sb126",
    "Te120","Te122","Te123","Te124","Te125","Te126","Te127m","Te128","Te129m","Te130","Te132",
    "I127","I129","I130","I131","I135",
    "Xe124","Xe126","Xe128","Xe129","Xe130","Xe131.T2","Xe132","Xe133","Xe134","Xe135","Xe136",
    "Cs133.T2","Cs134","Cs135","Cs136","Cs137",
    "Ba130","Ba132","Ba134","Ba135","Ba136","Ba137","Ba138","Ba140",
    "La138","La139","La140",
    "Ce140","Ce141","Ce142","Ce143","Ce144",
    "Pr141","Pr143",
    "Nd142","Nd143","Nd144","Nd145","Nd146","Nd147","Nd148","Nd150",
    "Pm147","Pm148","Pm148m","Pm149","Pm151",
    "Sm144","Sm147","Sm148","Sm149","Sm150.T2","Sm151.U8","Sm152.U8","Sm153","Sm154",
    "Eu151","Eu152","Eu153.T2","Eu154","Eu155","Eu156","Eu157",
    "Gd152","Gd153","Gd154","Gd155","Gd156","Gd157","Gd158","Gd160",
    "Tb159","Tb160",
    "Dy154","Dy156","Dy158","Dy159","Dy160","Dy161","Dy162","Dy163","Dy164",
    "Ho165",
    "Er162","Er164","Er166","Er167","Er168","Er170",
    "Hf174","Hf176","Hf177","Hf178","Hf179","Hf180","Hf181","Hf182",
  };
  SetLibrary(cbglibdir,lib,fp_num,filename_fp);
};

//

void Burner::SetLibrary70g(string cbglibdir)
{
  PutGroup(70);

  string libdir=cbglibdir+"CBGLIB/j4.70g.iwt7/";
  string libdir2=cbglibdir+"CBGLIB/tdl11.70g.iwt7/";
  xslib.Initialize(libdir,"N-ENERGY");
  string filename_hm[]={
    // (Heavy nuclides : 21 nuclides)
    "U234","U235","U236","U237","U238",
    "Np237","Np239","Pu238","Pu239","Pu240",
    "Pu241","Pu242","Am241","Am242","Am242m",
    "Am243","Cm242","Cm243","Cm244","Cm245",
    "Cm246",
  };
  string filename_fp1[]={
    // (Fission products : 185 nuclides)
    "Ge073","Ge074","Ge076","As075","Se076",
    "Se077","Se078","Se079","Se080","Se082",
    "Br081","Kr082","Kr083","Kr084","Kr085",
    "Kr086","Rb085","Rb086","Rb087","Sr086",
    "Sr087","Sr088","Sr089","Sr090","Y089",
    "Y090","Y091","Zr090","Zr091","Zr092",
    "Zr093","Zr094","Zr095","Zr096","Nb093",
    "Nb094","Nb095","Mo092","Mo094","Mo095",
    "Mo096","Mo097","Mo098","Mo099","Mo100",
    "Tc099","Ru100","Ru101","Ru102","Ru103",
    "Ru104","Ru105","Ru106","Rh103","Rh105",
    "Pd104","Pd105","Pd106","Pd107","Pd108",
    "Pd110","Ag107","Ag109","Ag110m","Cd110",
    "Cd111","Cd112","Cd113","Cd114","Cd116",
    "In113","In115","Sn116","Sn117","Sn118",
    "Sn119","Sn120","Sn122","Sn123","Sn124",
    "Sn126","Sb121","Sb123","Sb124","Sb125",
    "Sb126","Te122","Te123","Te124","Te125",
    "Te126","Te127m","Te128","Te129m","Te130",
    "Te132","I127","I129","I130","I131",
    "I135","Xe126","Xe128","Xe129","Xe130",
    "Xe131","Xe132","Xe133","Xe134","Xe135",
    "Xe136","Cs133","Cs134","Cs135","Cs136",
    "Cs137","Ba134","Ba135","Ba136","Ba137",
    "Ba138","Ba140","La139","La140","Ce140",
    "Ce141","Ce142","Ce143","Ce144","Pr141",
    "Pr143","Nd142","Nd143","Nd144","Nd145",
    "Nd146","Nd147","Nd148","Nd150","Pm147",
    "Pm148","Pm148m","Pm149","Pm151","Sm147",
    "Sm148","Sm149","Sm150","Sm151","Sm152",
    "Sm153","Sm154","Eu151","Eu152","Eu153.T2",
    "Eu154","Eu155","Eu156","Eu157","Gd152",
    "Gd154","Gd155","Gd156","Gd157","Gd158",
    "Gd160","Tb159","Tb160","Dy160","Dy161",
    "Dy162","Dy163","Dy164","Ho165","Er162",
    "Er164","Er166","Er167","Er168","Er170",
    "Hf176","Hf177","Hf178","Hf179","Hf180",
  };
  string filename_str[]={
    // (light or medium-heavy nuclides : 11 nuclides)
    "O016","Zr000","H001","B010","Fe000",
    "Cr000","Ni000","B011","Na023","Mn055",
    "Mo000","Co059"
  };
  string filename_fp2[]={
    "Nb093m","Rh106","Cd113m","Sn119m","Sn121",
    "Sn121m","Sb126m","Te123m","Te125m","Ba137m",
    "Pr144","Ho163","Ho166m",
  };

  xslib.ReadFile(21,libdir,filename_hm);
  xslib.ReadFile(185,libdir,filename_fp1);
  xslib.ReadFile(12,libdir,filename_str);
  xslib.ReadFile(13,libdir2,filename_fp2);
};

//

void Burner::CalHeavyMetalInitialWeight(Burnup &bu)
{
  hm_weight_init=bu.CalWeightOfHeavyNuclideParUnitVolume(med[0])*fuel_vol; // [g] (NOT [g/cm3])

  if(input_power_unit=="MW_t"){
    input_power_unit="W_cm";
    for(int i=0;i<burn_step;i++){
      power_density_list[i]*=hm_weight_init;
    };
  };

  /*
  cout<<"# Power density [W/cm]\n";
  for(int i=0;i<burn_step;i++){
    cout<<i<<" "<<power_density_list[i]<<"\n";
  };
  */
};

void Burner::CalHHMRatio()
{
  int nucn=med[0].GetNucnum();
  real den_hm=0.;
  for(int i=0;i<nucn;i++){
    int matno=med[0].GetNuclideInTurn(i).GetMatnum();
    if(matno>=900000)den_hm+=med[0].GetNuclideInTurn(i).GetDensity();
  };
  den_hm*=fuel_vol;

  int nucn2=med[2].GetNucnum();
  real den_h=0.;
  for(int i=0;i<nucn2;i++){
    int matno=med[2].GetNuclideInTurn(i).GetMatnum();
    if(matno==10010)den_h+=med[2].GetNuclideInTurn(i).GetDensity();
  }; 
  den_h*=mod_vol;

  cout<<"#\n# H/HM = "<<den_h/den_hm<<"\n#\n";
};

void Burner::PreCalculation(bool burn_time_cal)
{
  // +++ Pre self-shielding calculation +++++++++++++++++++++++++++++++++++++++++++++++++
  opc.GiveInfiniteDillutionCrossSection(med[0],xslib);
  opc.GiveInfiniteDillutionCrossSection(med[1],xslib);
  opc.GiveInfiniteDillutionCrossSection(med[2],xslib);
  if(up_scattering)opc.CalThermalScatteringMatrix(med[2],xslib, 3.93); // 3.93 : thermal cut-off energy
  med[2].CalSigtr(0);

  for(int i=0;i<nucn;i++){
    nuclide_info[i]=0;
    if(med[0].GetNuclideInTurn(i).GetGrp()!=-1){
      nuclide_info[i]=2;
      bool fissile=false;
      for(int g=0;g<group;g++){
	if(med[0].GetNuclideInTurn(i).GetMicxs().GetData1d(sigf).get_dat(g)){
	  fissile=true;
	  break;
	};
      };
      if(fissile)nuclide_info[i]=1;
    };
  };

  if(burn_time_cal)PreCalculation_bt();
};

void Burner::PreCalculation_bt()
{
  if(burn_time_calc)return;
 
  burn_time_calc=true;
  //
  if(burn_time_accumulate){
    for(int i=burn_step-1;i>0;i--){
      if(power_density_list[i]>0.){
	bool tag=false;
	for(int j=i-1;j>=0;j--){
          if(power_density_list[j]>0.&&!tag){
	    tag=true;
            burn_time[i]-=burn_time[j];
	  };
	};
      };
    };
  };

  if(burn_time_GWd_t){
    for(int i=0;i<burn_step;i++){
      burn_time_gwd[i]=burn_time[i];
      if(power_density_list[i]==0.){
        burn_time_gwd[i]=0.;
      }else{
        burn_time[i]*=hm_weight_init*1e-6/1e-9/power_density_list[i];
      };
    };
  }else{
    for(int i=0;i<burn_step;i++){
      if(power_density_list[i]==0.){
        burn_time_gwd[i]=0.;      
      }else{
        burn_time_gwd[i]=burn_time[i]/(hm_weight_init*1e-6/1e-9/power_density_list[i]);
      };
    };
  };

  for(int i=0;i<burn_step;i++){
    //if(power_density_list[i]==0.)sub_step_list[i]=1;
    //if(power_density_list[i]==0.)sub_step_list[i]=sub_step_org; //kawamoto
    if(power_density_list[i]==0.)sub_step_list[i]=40; //kawamoto
  };

  for(int i=0;i<burn_step;i++){
    if(burn_time[i]<=0.){
      cout<<"#\n# Error in Burner::PreCalculation_bt\n";
      cout<<"# Time(burnup) interval of step "<<i<<" is less than 0.\n#\n";
      exit(0);
    };
  };
};

void Burner::SelfShieldingCalculation(int step,GroupData1D &bell_default)
{
  cout<<"#\n# ... self-shielding calculation ...\n";

  if(step==0){
    ssc.ThreeRegionDancoffMethod(xslib,sys,med[0],med[1],med[2],true);
    dancoff=ssc.GetDancoff(0);
  }else{
    opc.CalSelfShieldingWithDancoffCorrection(med[0],xslib,fuel_r*2.,bell_default,dancoff);
    med[0].CalSigtr(0);
  };

  // Thermal scattering matrices are over-written
  if(up_scattering)opc.CalThermalScatteringMatrix(med[0],xslib,3.93);
  //opc.CalIncidentEnergyDependentChi(med[0],xslib);
  //opc.CalIncidentEnergyDependentChi(med[0],xslib,xslib.GetWtflux());
  opc.CalFissionSpectrumMatrix(med[0],xslib);

  cout<<"#      ... end\n";
};

void Burner::BeffCalculation(DelayedNeutronData &dnd)
{
  PreCalculation(false);
  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  SelfShieldingCalculation(0,b);

  GeneralOption opt,opta;
  opta.PutAdjointCal();

  PJISystem lata(group,3);
  lata.PutTrajectorySet(&sys_f);
  lata.AddMedium(med[0]);
  lata.AddMedium(med[1]);
  lata.AddMedium(med[2]);
  lata.PutRegMed(region_medium);
  lata.PutGeneralOption(opta);
  lata.PutSigmaCol(sigtr);
  lata.PutPij();
  lata.CalIgenPij();

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  lat.CalIgenPij();

  lata.CalBetaEffective(&lat,dnd);
};

real Burner::EigenvalueCalculation(bool vid)
{
  Medium med2_copy=med[2];
  if(vid){
    for(int i=0;i<med[2].GetNucnum();i++){
      int mat=med[2].GetNuclideInTurn(i).GetMatnum();
      real den=med[2].GetNuclideInTurn(i).GetDensity();
      if(mat==10010||mat==80160)den*=0.9;
      med[2].GetNuclideInTurn(i).PutDensity(den);
    };
    med[2].CalMacroFromMicro();
  };

  PreCalculation(false);

  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  SelfShieldingCalculation(0,b);

  GeneralOption opt;

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  med[2]=med2_copy;
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  return lat.CalIgenPij(true);
};

GroupData1D Burner::GetFuelNeutronFluxInitialState()
{
  PreCalculation(false);
  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  SelfShieldingCalculation(0,b);


  GeneralOption opt;

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  lat.CalIgenPij();

  GroupData1D flx=lat.GetIntegratedFluxMeshID(0,mesh_fuel-1);
  return flx;
};


void Burner::Cal1groupBranchingRatio(string cbglibdir,string filename,string outname)
{
  // Eigenvalue calculation to obtain neutron energy spectrum

  PreCalculation(false);
  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  SelfShieldingCalculation(0,b);

  GeneralOption opt;

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  lat.CalIgenPij();

  GroupData1D flx=lat.GetIntegratedFluxMeshID(0,mesh_fuel-1);
  GroupData1D dat(group);
  int bgrp[]={0};
  bgrp[0]=group-1;

  ifstream fin;
  string libdir=cbglibdir+"CBGLIB/CBG_Chain/";
  libdir.append(filename);
  fin.open(libdir.data(),ios::in);
  if(fin.fail()){
    cout<<"# Failed to open the file.\n";
    cout<<"# File name is "<<libdir<<"\n";
    exit(0);
  };

  int tmp;
  fin>>tmp;
  if(tmp!=group){
    cout<<"# Error in Burner::OverWritingNGBranchingRatioData\n";
    cout<<"# The number of groups is inconsistent.\n";
    exit(0);
  };

  ofstream fout;
  fout.open(outname.data(),ios::out);
  if(fout.fail()){
    cout<<"# Failed to open the file in Burner::Cal1groupNGBranchingRatio.\n";
    exit(1);
  };

  int mat=999;
  while(mat!=-1){
    fin>>mat;
    if(mat==-1){
      fout<<"-1";
      fin.close();
      fout.close();
      return;
    };

    int flag;
    fin>>flag;

    int ich;
    fin>>ich;

    bool process=true;
    GroupData1D ngxs;
    if(xslib.ExistLibData(mat)){
      if(flag==0)ngxs=xslib.GetLibData(mat).GetXSData().GetData1d(sigc);
      if(flag==1)ngxs=xslib.GetLibData(mat).GetXSData().GetData1d(sign2n);
      real sum=ngxs.get_sum();
      if(sum==0.)process=false;
    }else{
      process=false;
    };

    if(process){
      fout.setf(ios::showpoint);
      fout.precision(9);
      ngxs=ngxs.mult(flx);
      fout<<"   "<<mat<<"\n";
      fout<<"   "<<flag<<"\n";
      fout<<"   "<<ich<<"\n";
      vector<real> br(ich);
      for(int i=0;i<ich;i++){
	fin>>tmp;
        for(int j=0;j<group;j++){
	  real tmpr;
	  fin>>tmpr;
	  dat.put_data(j,tmpr);
	};
        br[i]=dat.Cond(ngxs,1,bgrp).get_dat(0);
      };
      if(flag==1){
	real sum=0.;
	for(int i=0;i<ich;i++){
	  sum+=br[i];
	};
	for(int i=0;i<ich;i++){
	  br[i]/=sum;
	};
      };
      for(int i=0;i<ich;i++){
	fout<<"   "<<br[i]<<"\n";
      };
    }else{
      for(int i=0;i<ich;i++){
        fin>>tmp;
        for(int j=0;j<group;j++){
          real tmpr;
          fin>>tmpr;
	};
      };
    };
  };

  fin.close();
};

void Burner::ConstructingFuelNuclide(Burnup &bu)
{
  //
  // Instances of the nuclide class are stored in acsending MATID order
  // to perform efficient burnup calculation with CRAM.
  //
  bu.AddNuclideToMediumFromBurnupChain(med[0]);
  PutNucn(med[0].GetNucnum());
};

void Burner::PutNucn(int i)
{
  nucn=i;
  nuclide_info.resize(nucn);
};

void Burner::Calculation(Burnup &bu,bool adjoint)
{
  setlinebuf(stdout);

  ConstructingFuelNuclide(bu);
  if(hm_weight_init==0.)CalHeavyMetalInitialWeight(bu);
  PreCalculation();

  //
  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  GeneralOption opt;

  // +++ Number density data storing ++++++++++++++++++++++++++++++++++++++++++++++++++++
  density_data.resize(burn_step+1);
  xsc_1g.resize(burn_step+1);
  xsn2n_1g.resize(burn_step+1);
  xsf_1g.resize(burn_step+1);
  fuel_flux.resize(burn_step+1);
  clad_flux.resize(burn_step+1);

  power_factor.resize(burn_step);
  delt.resize(burn_step);
  total_flux.resize(burn_step);
  total_flux_clad.resize(burn_step);
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    delt[i].resize(sub_step);
    power_factor[i].resize(sub_step+1);
    total_flux[i].resize(sub_step);
    total_flux_clad[i].resize(sub_step);
  };

  Burnup bu_dmdf;

  // +++ for sensitivity calculation +++++++++++++++++++++++++++++++++++++++
  if(adjoint){
    bu_dmdf=bu;
    SetArrayForSensitivityCalculation();
    adj_nuc_data=true;
  };
  // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  real bu0=0.;
  real accumulated_day=0.;
  real accumulated_burn=0.;
  for(int st=0;st<burn_step+1;st++){

    //acday[st]=accumulated_day;
    //acburn[st]=accumulated_burn;
    acday.push_back(accumulated_day);
    acburn.push_back(accumulated_burn);

    cout<<"#\n# +++ Burnup step : "<<st<<"\n";
    cout<<"#     (accumulated day : "<<accumulated_day<<" )\n";

    density_data[st].resize(nucn);
    for(int i=0;i<nucn;i++){
      density_data[st][i]=med[0].GetNuclideInTurn(i).GetDensity();
    };

    SelfShieldingCalculation(st,b);

   // +++ Eigenvalue calculation
    PJISystem lat(group,3);
    lat.PutTrajectorySet(&sys_f);
    lat.AddMedium(med[0]);
    lat.AddMedium(med[1]);
    lat.AddMedium(med[2]);
    lat.PutRegMed(region_medium);
    lat.PutGeneralOption(opt);
    lat.PutSigmaCol(sigtr);
    lat.PutPij();
    keff[st]=lat.CalIgenPij(true); // `true' means matrix chi 

    real vol_inv=1./fuel_vol;
    fuel_flux[st]=lat.GetIntegratedFluxMeshID(0,mesh_fuel-1)*vol_inv;
    clad_flux[st]=lat.GetIntegratedFluxMeshID(mesh_fuel,mesh_fuel+mesh_clad-1)/clad_vol;

    // Total-flux per unit volume in fuel region
    med[0].GetFlux().copy(fuel_flux[st]);

    opc.CalEquivalentFissionSpectrumVector(med[0],fuel_flux[st]);

    bu.PutMediumData(med[0]); // burnup data

    // +++ one-group cross section storing
    xsc_1g[st].resize(nucn);
    xsn2n_1g[st].resize(nucn);
    xsf_1g[st].resize(nucn);
    for(int j=0;j<nucn;j++){
      xsf_1g[st][j]=bu.GetSigf(j);
      xsc_1g[st][j]=bu.GetSigc(j);
      xsn2n_1g[st][j]=bu.GetSign2n(j);
    };

    if(limit_burnup){
      if(bu0==0.){
	if(keff[st]<k_limit){
          bu0=acburn[st-1]+(acburn[st]-acburn[st-1])/(keff[st-1]-keff[st])*(k_limit-keff[st]);
	};
      }else{
        bumax=bu0*2*batch/(batch+1);
	if(acburn[st]>bumax){
          cout<<"#\n# Burnup calculation is forced to be terminated in a limited burnup.\n#\n";
          burn_step=st;
          return;
	};
      };
    };

    if(st!=burn_step){
      // +++ (for sensitivity calculation) +++++++++++++++++++++++++
      if(adjoint){
        macxs[st].DataCopyPL(med[0].GetMacxs(),0);
        if(st==0)trmat_flxindep=bu.GetTrmatFlxInDep();
        for(int i=0;i<mesh_fuel;i++){
          volflx_mesh[st][i]=lat.GetMesh(i).GetFlux()*lat.GetMesh(i).GetVolume();
        };
        for(int k=0;k<nucn;k++){
	  if(nuclide_info[k]!=0){
            if(nuclide_info[k]==1)mic_sigf[st][k].copy(med[0].GetNuclideInTurn(k).GetMicxs().GetData1d(sigf));
            mic_sigc[st][k].copy(med[0].GetNuclideInTurn(k).GetMicxs().GetData1d(sigc));
	  };
        };
      };
      // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      real power_density=power_density_list[st];
      real burn_span=burn_time[st]; // day

      int sub_step=sub_step_list[st];
      burn_span/=sub_step;
    
      // +++ Burnup calculation
      if(!input_flux_level)accumulated_burn+=burn_time_gwd[st];
      cout<<"#... burnup calculation (total step:"<<sub_step<<")\n";
      real flx1g=fuel_flux[st].get_sum();
      real flx1g_clad=clad_flux[st].get_sum();

      for(int j=0;j<sub_step;j++){
	//cout<<"#... burnup calculation : "<<j<<"/"<<sub_step<<"\n";   

	// +++ (for sensitivity calculation) ++++++++++++++++++++++++++++++
	if(adjoint){
          for(int i=0;i<nucn;i++){
	    fwd_nuc[st][j].put_data(i,med[0].GetNuclideInTurn(i).GetDensity());
          };
	};
	// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        power_factor[st][j]=power_density/(bu.GetIntegratedPower(med[0])*fuel_vol);
        total_flux[st][j]=flx1g*power_factor[st][j];
        total_flux_clad[st][j]=flx1g_clad*power_factor[st][j];
	if(input_flux_level){
          real ratio=flx1g_clad/flx1g;
          total_flux[st][j]=flux_level_list[st];
	  total_flux_clad[st][j]=total_flux[st][j]*ratio;
          real power_org=bu.GetIntegratedPower(med[0])*fuel_vol;
          power_density=power_org*total_flux[st][j]/flx1g;
          accumulated_burn+=(power_density*1e-9)/(hm_weight_init*1e-6)*burn_span;
	};
	accumulated_day+=burn_span;
	delt[st][j]=burn_span*24*60*60;
	// +++ (for burnup-matrix extraction)+++++++++++++++
	if(j==0&&matrix_extract){
	  ofstream fout;
	  string tmp="./"+mat_ext_filename+"_step"+IntToString(st);
	  fout.open(tmp.data(),ios::out);
	  if(fout.fail()){
	    cout<<"# Failed to open the file.\n";
	    exit(1);
	  };
	  fout.setf(ios::scientific);
	  fout.precision(mat_ext_prc);
          fout<<nucn<<"\n";
	  for(int i=0;i<nucn;i++){
	    int mn=med[0].GetNuclideInTurn(i).GetMatnum();
	    fout<<mn<<"\n";
  	    fout<<"   "<<midt.Name(mn)<<"\n";
	  };
	  GroupData2D mat=bu.CalTransitionMatrix(total_flux[st][j]);
	  for(int i=0;i<nucn;i++){
	    for(int j=0;j<nucn;j++){
	      fout<<mat.get_dat(i,j)<<"\n";
	    };
	  };
	  fout.close();
	};
	// ++++++++++++++++++++++++++++++++++++++++++++++++++
        //bu.BurnupCalculationByKrylov(med[0],total_flux[st][j],delt[st][j],false);
        //bu.BurnupCalculationByChebyshev(med[0],total_flux[st][j],delt[st][j],false);
        bu.BurnupCalculationByMMPA(med[0],total_flux[st][j],delt[st][j],false);
	//cout<<"#  Flux level    : "<<total_flux[st][j]<<" [/s/cm2]\n";
	//cout<<"#  Power density : "<<power_density<<" [W/cm]\n";
      };

      // +++ (for sensitivity calculation)
      if(adjoint){
        for(int i=0;i<nucn;i++){
  	  fwd_nuc[st][sub_step].put_data(i,med[0].GetNuclideInTurn(i).GetDensity());
        };

        for(int jj=0;jj<group;jj++){
          GroupData2D tmp=bu_dmdf.CaldTMatdFlux(med[0],jj);
          for(int j=0;j<sub_step+1;j++){
            dmdf_nuc[st][j][jj]=tmp*fwd_nuc[st][j];
	  };
  	};

      };

      // ++++++++++++++++++++++++++++

      cout<<"#    ... terminated.\n";
    };
  };
};

void Burner::dkdN_Calculation(Burnup &bu,string filename)
{
  setlinebuf(stdout);

  ConstructingFuelNuclide(bu);
  if(hm_weight_init==0.)CalHeavyMetalInitialWeight(bu);
  PreCalculation();
  //
  GroupData1D b(group); // Bell factor
  for(int i=0;i<group;i++){b.put_data(i,1.2);};
  // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  GeneralOption opt,opta;
  opta.PutAdjointCal();

  power_factor.resize(burn_step);
  delt.resize(burn_step);
  total_flux.resize(burn_step);
  fuel_flux.resize(burn_step+1);
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    delt[i].resize(sub_step);
    power_factor[i].resize(sub_step+1);
    total_flux[i].resize(sub_step);
  };

  // +++ dkdN_storing
  vector< vector<real> > dkdN(burn_step+1);
  for(int i=0;i<burn_step+1;i++){
    dkdN[i].resize(nucn,0.);
  };

  real accumulated_day=0.;
  real accumulated_burn=0.;
  for(int st=0;st<burn_step+1;st++){

    //acday[st]=accumulated_day;
    //acburn[st]=accumulated_burn;
    acday.push_back(accumulated_day);
    acburn.push_back(accumulated_burn);

    cout<<"#\n# +++ Burnup step : "<<st<<"\n";
    cout<<"#     (accumulated day : "<<accumulated_day<<" )\n";

    SelfShieldingCalculation(st,b);

    med[0].CalMacroFromMicroSimple();

    // +++ Eigenvalue calculation
    PJISystem lata(group,3);
    lata.PutTrajectorySet(&sys_f);
    lata.AddMedium(med[0]);
    lata.AddMedium(med[1]);
    lata.AddMedium(med[2]);
    lata.PutRegMed(region_medium);
    lata.PutGeneralOption(opta);
    lata.PutSigmaCol(sigtr);
    lata.PutPij();
    real k_adj=lata.CalIgenPij();

    PJISystem lat(group,3);
    lat.PutTrajectorySet(&sys_f);
    lat.AddMedium(med[0]);
    lat.AddMedium(med[1]);
    lat.AddMedium(med[2]);
    lat.PutRegMed(region_medium);
    lat.PutGeneralOption(opt);
    lat.PutSigmaCol(sigtr);
    lat.PutPij();
    keff[st]=lat.CalIgenPij();
 
    for(int i=0;i<nucn;i++){
      cout<<"  dkdn calculation : "<<i<<"/"<<nucn<<"\n";
      real org=med[0].GetNuclideInTurn(i).GetDensity();
      real sns=0.;
      if(org!=0.){
        lat.GetMedium(0).GetNuclideInTurn(i).PutDensity(org*1.01);
        lat.GetMedium(0).CalMacroFromMicroSimple();
        sns=lata.CalReactivity(&lat,k_adj,keff[st],false)*k_adj*100.;
        lat.GetMedium(0).GetNuclideInTurn(i).PutDensity(org);
      };
      dkdN[st][i]=sns;
    };

    real vol_inv=1./fuel_vol;
    fuel_flux[st]=lat.GetIntegratedFluxMeshID(0,mesh_fuel-1)*vol_inv;
    // Total-flux per unit volume in fuel region
    med[0].GetFlux().copy(fuel_flux[st]);

    bu.PutMediumData(med[0]); // burnup data

    if(st!=burn_step){

      real power_density=power_density_list[st];
      real burn_span=burn_time[st]; // day

      int sub_step=sub_step_list[st];
      burn_span/=sub_step;
    
      // +++ Burnup calculation
      if(!input_flux_level)accumulated_burn+=burn_time_gwd[st];
      cout<<"#... burnup calculation (total step:"<<sub_step<<")\n";
      real flx1g=fuel_flux[st].get_sum();
      for(int j=0;j<sub_step;j++){
        power_factor[st][j]=power_density/(bu.GetIntegratedPower(med[0])*fuel_vol);
        total_flux[st][j]=flx1g*power_factor[st][j];
	if(input_flux_level){
          total_flux[st][j]=flux_level_list[st];
          real power_org=bu.GetIntegratedPower(med[0])*fuel_vol;
          power_density=power_org*total_flux[st][j]/flx1g;
          accumulated_burn+=(power_density*1e-9)/(hm_weight_init*1e-6)*burn_span;
	};
	accumulated_day+=burn_span;
	delt[st][j]=burn_span*24*60*60;
        bu.BurnupCalculationByChebyshev(med[0],total_flux[st][j],delt[st][j],false);
      };

      cout<<"#    ... terminated.\n";
    };
  };

  // +++ Editing
  ofstream fout;
  string fname="./"+filename;
  fout.open(fname.data(),ios::out);
  if(fout.fail()){
    cout<<"# Failed to open the file in Burner::dkdN_Calculation.\n";
    exit(1);
  };

  fout.setf(ios::showpoint);
  fout.precision(5);

  int judge_num=7;
  real judge[]={1., 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001};
  for(int jj=0;jj<judge_num;jj++){
    fout<<"#\n# Maximum (dk/k)/(dn/n) through burnup\n";
    fout<<"#  [criteria : "<<judge[jj]<<"]\n#\n";
    for(int i=0;i<nucn;i++){
      int mmt=med[0].GetNuclideInTurn(i).GetMatnum();
      real maxval=0.;
      for(int j=0;j<burn_step+1;j++){
        if(abs(dkdN[j][i])>maxval)maxval=abs(dkdN[j][i]);
      };
      if(maxval>judge[jj]){
        fout<<midt.Name(mmt)<<" "<<maxval<<"\n";
      };
    };
    fout<<"\n\n";
  };

  fout<<"#\n";
  fout<<"# Burnup-dependent keff sensitivity\n";
  fout<<"#\n";
  for(int i=0;i<burn_step+1;i++){
    fout<<"# Burnup step : "<<i<<"\n";
    fout<<"# Accumulated day : "<<acday[i]<<"\n";
    fout<<"# Burnup : "<<acburn[i]<<"\n";
    fout<<"#\n";
    for(int j=0;j<nucn;j++){
      if(dkdN[i][j]!=0.){
        fout<<"  "<<midt.Name(med[0].GetNuclideInTurn(j).GetMatnum())<<" ";
        fout<<dkdN[i][j]<<"\n";
      };
    };
    fout<<"#\n#\n";
  };

  vector<real> dkdn_max(nucn,0.);
  fout<<"#\n# Burnup dependent (dk/k)/(dn/n) per each nuclide\n#\n";
  for(int i=0;i<nucn;i++){
    int mmt=med[0].GetNuclideInTurn(i).GetMatnum();
    fout<<"# "<<midt.Name(mmt)<<"\n";
    fout<<"# [day] [GWd/t] [(dk/k)/(dn/n)]\n";
    for(int j=0;j<burn_step+1;j++){
      fout<<acday[j]<<" "<<acburn[j]<<" "<<dkdN[j][i]<<"\n";
      if(fabs(dkdN[j][i])>dkdn_max[i])dkdn_max[i]=dkdN[j][i];
    };
    fout<<"\n\n";
  };

  fout<<"# Maximum dk/dn for each nuclide\n";
  for(int i=0;i<nucn;i++){
    fout<<"#  "<<midt.Name(med[0].GetNuclideInTurn(i).GetMatnum())<<" ";
    fout<<dkdn_max[i]<<"\n";
  };

};

void Burner::NuclideWiseReactivityEffectCalculationDuringCooling(Burnup &bu, int nuc, string *nuc_name)
{
  // substep is fixed to 1.
  int sub_step=1;

  vector< vector<real> > react(nuc);
  vector<int> nuc_turn(nuc);
  GetPrintNuclide(nuc,nuc_name,nuc_turn);

  //ConstructingFuelNuclide(bu); 
  for(int i=0;i<burn_step;i++){
    power_density_list[i]=0.;
  };
  PreCalculation_bt();

  // forward/adjoint calculation at t=0
  GeneralOption opt,opta;
  opta.PutAdjointCal();

  med[0].CalMacroFromMicro();
  Medium med_org=med[0];

  PJISystem lata(group,3);
  lata.PutTrajectorySet(&sys_f);
  lata.AddMedium(med_org);
  lata.AddMedium(med[1]);
  lata.AddMedium(med[2]);
  lata.PutRegMed(region_medium);
  lata.PutGeneralOption(opta);
  lata.PutSigmaCol(sigtr);
  lata.PutPij();
  real k_adj=lata.CalIgenPij();

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med_org);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  real k_fwd=lat.CalIgenPij();

  // +++ Number density data storing ++++++++++++++++++++++++++++++++++++++++++++++++++++
  delt.resize(burn_step);
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    delt[i].resize(sub_step);
  };

  acday.clear();
  acburn.clear();
  density_data.clear();

  real accumulated_day=0.;
  for(int st=0;st<burn_step+1;st++){

    acday.push_back(accumulated_day);
    acburn.push_back(0.);

    vector<real> density_tmp(nucn);
    for(int i=0;i<nucn;i++){
      density_tmp[i]=med[0].GetNuclideInTurn(i).GetDensity();
    };
    density_data.push_back(density_tmp);

    cout<<"#\n# +++ Burnup step : "<<st<<"\n";
    cout<<"#     (accumulated day : "<<accumulated_day<<" )\n";

    bu.PutMediumDataWithZeroCrossSection(med[0]); // burnup data

    if(st!=burn_step){

      real burn_span=burn_time[st]; // day
      burn_span/=sub_step;
      // +++ Burnup calculation
      cout<<"#... burnup calculation (total step:"<<sub_step<<")\n";
      for(int j=0;j<sub_step;j++){
	accumulated_day+=burn_span;
	delt[st][j]=burn_span*24*60*60;
        bu.BurnupCalculationByChebyshev(med[0],0.,delt[st][j],false);
      };

      // perturbation calculation
      for(int i=0;i<nuc;i++){
        real den_org=med_org.GetNuclideInTurn(nuc_turn[i]).GetDensity();
        real den_new=med[0].GetNuclideInTurn(nuc_turn[i]).GetDensity();
        med_org.GetNuclideInTurn(nuc_turn[i]).PutDensity(den_new);
        med_org.CalMacroFromMicro();
        lat.GetMedium(0).GetMacxs().DataCopy(med_org.GetMacxs());
        real tmp=lata.CalReactivity(&lat,k_adj,k_fwd,false);
        react[i].push_back(tmp);
        med_org.GetNuclideInTurn(nuc_turn[i]).PutDensity(den_org);
      };


      cout<<"#    ... terminated.\n";
    };
  };

  cout<<"# Nuclide-wise reactivity effect during cooling period.\n";
  cout<<"#  Day     ";
  for(int i=0;i<nuc;i++){
    WriteOut(nuc_name[i],11);
  };
  cout<<"\n";

  cout.setf(ios::scientific);
  cout.precision(3);
  for(int i=0;i<burn_step;i++){
    cout<<acday[i+1]<<" ";
    for(int j=0;j<nuc;j++){
      if(react[j][i]>=0.)cout<<" ";
      cout<<react[j][i]<<" ";
    };
    cout<<"\n";
  };

};

void Burner::CoolingCalculation(Burnup &bu,int sub_step)
{
  ConstructingFuelNuclide(bu); 
  for(int i=0;i<burn_step;i++){
    power_density_list[i]=0.;
  };
  PreCalculation_bt();
  
  // +++ Number density data storing ++++++++++++++++++++++++++++++++++++++++++++++++++++
  //density_data.resize(burn_step+1);
  delt.resize(burn_step);
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    delt[i].resize(sub_step);
  };

  if(!cooling_cal){
    acday.clear();
    acburn.clear();
    density_data.clear();
  };

  real accumulated_day=0.;
  if(cooling_cal){
    int sz=acday.size();
    accumulated_day=acday[sz-1];
  };

  for(int st=0;st<burn_step+1;st++){

    if(!cooling_cal||st!=0){
      acday.push_back(accumulated_day);
      acburn.push_back(0.);

      vector<real> density_tmp(nucn);
      for(int i=0;i<nucn;i++){
        density_tmp[i]=med[0].GetNuclideInTurn(i).GetDensity();
      };
      density_data.push_back(density_tmp);
    };

    cout<<"#\n# +++ Burnup step : "<<st<<"\n";
    cout<<"#     (accumulated day : "<<accumulated_day<<" )\n";

    //density_data[st].resize(nucn);
    //for(int i=0;i<nucn;i++){
    //density_data[st][i]=med[0].GetNuclideInTurn(i).GetDensity();
    //};

    bu.PutMediumDataWithZeroCrossSection(med[0]); // burnup data

    if(st!=burn_step){

      real burn_span=burn_time[st]; // day
      burn_span/=sub_step;
      // +++ Burnup calculation
      cout<<"#... burnup calculation (total step:"<<sub_step<<")\n";
      for(int j=0;j<sub_step;j++){
	accumulated_day+=burn_span;
	delt[st][j]=burn_span*24*60*60;
        //bu.BurnupCalculationByKrylov(med[0],0.,delt[st][j],false);
        //bu.BurnupCalculationByChebyshev(med[0],0.,delt[st][j],false);
        bu.BurnupCalculationByMMPA(med[0],0.,delt[st][j],false);
      };

      cout<<"#    ... terminated.\n";
    };
  };

  cooling_cal=true;
  int sz=acday.size();
  burn_step=sz-1;
};

real Burner::CalMacroscopicReactionRate(int nuc,int *nuc_id,enum xstype *xs,bool *on_mesh)
{
  GeneralOption opt;
  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  lat.CalIgenPij();
  return lat.CalMacroscopicReactionRate(nuc,nuc_id,xs,on_mesh);
};

void Burner::CalculationHomogeneous(Burnup &bu)
{
  fuel_vol=1.;
  setlinebuf(stdout);

  //if(hm_weight_init==0.)hm_weight_init=bu.CalWeightOfHeavyNuclideParUnitVolume(med[0])*fuel_vol; // [g] (NOT [g/cm3])
  ConstructingFuelNuclide(bu);
  if(hm_weight_init==0.)CalHeavyMetalInitialWeight(bu);
  PreCalculation_bt();

  // +++ Number density data storing ++++++++++++++++++++++++++++++++++++++++++++++++++++
  density_data.resize(burn_step+1);
  xsc_1g.resize(burn_step+1);
  xsn2n_1g.resize(burn_step+1);
  xsf_1g.resize(burn_step+1);
  fuel_flux.resize(burn_step+1);

  real accumulated_day=0.;
  real accumulated_burn=0.;
  for(int st=0;st<burn_step+1;st++){

    //acday[st]=accumulated_day;
    //acburn[st]=accumulated_burn;
    acday.push_back(accumulated_day);
    acburn.push_back(accumulated_burn);

    cout<<"#\n# +++ Burnup step : "<<st<<"\n";
    cout<<"#     (accumulated day : "<<accumulated_day<<" )\n";

    density_data[st].resize(nucn);
    for(int i=0;i<nucn;i++){
      density_data[st][i]=med[0].GetNuclideInTurn(i).GetDensity();
    };

    opc.CalSelfShieldingInfiniteSystem(med[0],xslib);
    med[0].CalMacroFromMicro();

    med[0].CalHomoB1(0.);
    keff[st]=med[0].CalKeff();
    fuel_flux[st]=med[0].GetFlux();

    bu.PutMediumData(med[0]); // burnup data

    // +++ one-group cross section printing
    xsc_1g[st].resize(nucn);
    xsn2n_1g[st].resize(nucn);
    xsf_1g[st].resize(nucn);
    for(int j=0;j<nucn;j++){
      xsf_1g[st][j]=bu.GetSigf(j);
      xsc_1g[st][j]=bu.GetSigc(j);
      xsn2n_1g[st][j]=bu.GetSign2n(j);
    };

    if(st!=burn_step){

      real power_density=power_density_list[st];
      real burn_span=burn_time[st]; // day

      int sub_step=sub_step_list[st];
      burn_span/=sub_step;
    
      // +++ Burnup calculation
      if(!input_flux_level)accumulated_burn+=burn_time_gwd[st];
      cout<<"#... burnup calculation (total step:"<<sub_step<<")\n";
      real flx1g=med[0].GetFlux().get_sum();
      for(int j=0;j<sub_step;j++){
	//cout<<"#... burnup calculation : "<<j<<"/"<<sub_step<<"\n";   
        real power_factor=power_density/bu.GetIntegratedPower(med[0]);
        real total_flux=flx1g*power_factor;
	if(input_flux_level){
          total_flux=flux_level_list[st];
          real power_org=bu.GetIntegratedPower(med[0]);
          power_density=power_org*total_flux/flx1g;
          accumulated_burn+=(power_density*1e-9)/(hm_weight_init*1e-6)*burn_span;
	};
	accumulated_day+=burn_span;
	real delt=burn_span*24*60*60;
        bu.BurnupCalculationByKrylov(med[0],total_flux,delt,false);
	cout<<"#  Flux level    : "<<total_flux<<" [/s/cm2]\n";
	//cout<<"#  Power density : "<<power_density<<" [W/cm]\n";
      };
      cout<<"#    ... terminated.\n";
    };
  };
};

void Burner::SensitivityCalculation(Burnup &bu,int target_nuclide_num,string *target_nuclide_snscal,bool fileout)
{
  // +++ Forward calculation
  Calculation(bu,true);

  // +++ for forward number density printing +++++++++++++++++++++++
  if(fileout)WriteFileNumberDensity("nuc_fwd");

  // (Sensitivity Calculation)
  AveragingForwardNumberDensity();
  for(int iii=0;iii<target_nuclide_num;iii++){

    cout<<"# Sensitivity calculation : "<<iii<<"/"<<target_nuclide_num<<"\n";
    int sub_step=sub_step_list[burn_step-1];
    // (initialization for final condition)
    for(int i=0;i<nucn;i++){
      adj_nuc_e[burn_step-1][sub_step-1].put_data(i,0.);
    };

    // (Set-up for final condition)
    int target_nuclideID=midt.ID(target_nuclide_snscal[iii]);
    int target_nuclideID_inturn=-1;
    for(int i=0;i<nucn;i++){
      if(med[0].GetNuclideInTurn(i).GetMatnum()==target_nuclideID){
        target_nuclideID_inturn=i;
        adj_nuc_e[burn_step-1][sub_step-1].put_data(i,1.);
      };
    };
    if(target_nuclideID_inturn==-1){
      cout<<"# Error in Burner::Sensitivity Calculation.\n";
      cout<<"# Targert nuclide "<<target_nuclide_snscal[iii]<<" cannot be found.\n";
      exit(0);
    };

    AdjointBurnupCalculation(bu);

    real end_nuc=med[0].GetNuclideInTurn(target_nuclideID_inturn).GetDensity();
    SensitivityPrinting(bu,end_nuc,"burner_pincell","number_density","unknown",target_nuclide_snscal[iii]);

    // +++ adjoint number density printing +++++++++++++++++++++++++++
    if(fileout){
      string fname="nuc_adj_"+target_nuclide_snscal[iii];
      WriteFileAdjointNumberDensity(fname,target_nuclideID);
      string fname2="cf_"+target_nuclide_snscal[iii];
      WriteFileContributionFunction(bu,fname2,target_nuclideID,end_nuc);    
    };

  }; // loop-end for nuclide

};

void Burner::SensitivityCalculationDecayHeat(Burnup &bu,bool beta,bool gamma,bool alpha)
{
  real ev_to_j=1.60219e-19;

  // +++ Forward calculation
  Calculation(bu,true);

  // (Sensitivity Calculation)
  AveragingForwardNumberDensity();

  cout<<"# Sensitivity calculation for decay heat\n";
  int sub_step=sub_step_list[burn_step-1];

  // (Set-up for final condition)
  real tmp=0.;
  real tmp1;
  real end_decayheat=0.;//[W/cm3]
  vector<int> nuc;
  vector<vector<real> > energy_sens;
  nuc.resize(nucn);
  energy_sens.resize(nucn);
  vector<bool> decay;
  decay.push_back(beta);
  decay.push_back(gamma);
  decay.push_back(alpha);

  for(int i=0;i<nucn;i++){
    int id=med[0].GetNuclideInTurn(i).GetMatnum();
    tmp1=0.;
    real decay_const=bu.GetBurnupChain().GetDecayConstant(id);
    real dens=med[0].GetNuclideInTurn(i).GetDensity();
    nuc[i]=id;
    energy_sens[i].resize(3);
    for(int j=0;j<3;j++){
      if(decay[j]==true){
	real energy=bu.GetBurnupChain().GetDecayEnergy(id,j);
	tmp1=tmp1+energy;
	energy_sens[i][j]=energy*decay_const*dens;
      }else if(decay[j]==false){
	energy_sens[i][j]=0.;
      };
    };
    tmp=tmp1*decay_const*ev_to_j*1e+24;
    end_decayheat=end_decayheat+tmp*dens;
    adj_nuc_e[burn_step-1][sub_step-1].put_data(i,tmp);
  };

  for(int i=0;i<nucn;i++){
    for(int j=0;j<3;j++){
      real tmp=energy_sens[i][j];
      energy_sens[i][j]=tmp/(end_decayheat/(ev_to_j*1e+24));
    };
  };

  AdjointBurnupCalculation(bu);
  SensitivityPrintingForDecayHeat(bu,end_decayheat,nuc,energy_sens);

};

void Burner::WriteFileNumberDensity(string filename)
{
  ofstream fout;
  fout.open(filename.data(),ios::out);
  if(fout.fail()){
    cout<<"# Failed to open the file in Burner::WriteFileNumberDensity.\n";
    exit(1);
  };
  fout<<"   "<<burn_step<<"\n";
  fout<<"   "<<nucn<<"\n";
  fout.setf(ios::scientific);
  fout.precision(5);
  for(int i=0;i<burn_step;i++){
    fout<<burn_time_gwd[i]<<"\n";
  };
  for(int i=0;i<nucn;i++){
    fout<<med[0].GetNuclideInTurn(i).GetMatnum()<<"\n";
    for(int j=0;j<burn_step;j++){
      int ss=sub_step_list[j];
      fout<<ss<<"\n";
      for(int k=0;k<ss;k++){
        fout<<(fwd_nuc[j][k].get_dat(i)+fwd_nuc[j][k+1].get_dat(i))*0.5<<"\n";
      };
    };
  };
  fout.close();
};

void Burner::WriteFileAdjointNumberDensity(string filename,int target_nuclideID)
{
  ofstream fout;
  fout.open(filename.data(),ios::out);
  if(fout.fail()){
    cout<<"# Failed to open the file in Burner::WriteFileAdjointNumberDensity.\n";
    exit(1);
  };

  fout<<"   "<<target_nuclideID<<"\n";
  fout<<"   "<<burn_step<<"\n";
  fout<<"   "<<nucn<<"\n";
  fout.setf(ios::scientific);
  fout.precision(5);
  for(int i=0;i<nucn;i++){
    fout<<med[0].GetNuclideInTurn(i).GetMatnum()<<"\n";
    for(int j=0;j<burn_step;j++){
      int ss=sub_step_list[j];
      fout<<ss<<"\n";
      for(int k=0;k<ss;k++){
        fout<<adj_nuc[j][k].get_dat(i)<<"\n";
      };
    };
  };

  fout.close();
};

void Burner::WriteFileContributionFunction(Burnup &bu,string filename,int target_nuclideID,real end_nuc)
{
  ofstream fout;
  fout.open(filename.data(),ios::out);
  if(fout.fail()){
    cout<<"# Failed to open the file in Burner::WriteFileContributionFunction.\n";
    exit(1);
  };

  fout<<"   "<<target_nuclideID<<"\n";
  fout<<"   "<<burn_step<<"\n";
  fout<<"   "<<nucn<<"\n";
  fout.setf(ios::scientific);
  fout.precision(5);

  for(int i=0;i<nucn;i++){
    fout<<"    "<<med[0].GetNuclideInTurn(i).GetMatnum()<<"\n";
    for(int j=burn_step-1;j>=0;j--){
      int ss=sub_step_list[j];
      fout<<ss<<"\n";
      for(int k=ss-1;k>=0;k--){
        real pf=power_factor[j][k];
	real cf=adj_nuc[j][k].get_dat(i)*fwd_nuc[j][k].get_dat(i)/end_nuc;
	if(nuclide_info[i]!=0){ // no cross section data
        real tmp=0.;
	for(int g=0;g<group;g++){
	  // [flux term]
	  for(int m=0;m<mesh_fuel;m++){
	    tmp+=volflx_mesh[j][m].get_dat(g)*pf*mic_sigc[j][i].get_dat(g)*gpt_flx[j][k][m].get_dat(g);
	    if(nuclide_info[i]==1){ // fissile
  	      real src=0.;
	      for(int gg=0;gg<group;gg++){
	        src+=volflx_mesh[j][m].get_dat(gg)*pf*mic_sigf[j][i].get_dat(gg)
	            *med[0].GetNuclideInTurn(i).GetMicxs().GetData1d(nu).get_dat(gg);
	      };
	      tmp-=macxs[j].GetData1d(chi).get_dat(g)*src/keff[j]*gpt_flx[j][k][m].get_dat(g);
	    };
	  };
  	  // [power normalization term]
	  if(nuclide_info[i]==1){
  	    int iid=med[0].GetNuclideInTurn(i).GetMatnum();
	    real flx=fuel_flux[j].get_dat(g)*pf*fuel_vol;
	    tmp-=pow_adj[j][k]*flx*mic_sigf[j][i].get_dat(g)*bu.GetReactionEnergyData().GetFissionEnergy(iid);
	  };
	};
        cf-=tmp*fwd_nuc[j][k].get_dat(i)/end_nuc;
	}; // 
	fout<<"  "<<cf<<"\n"; // contribution function
      };
    };
  };
};

void Burner::SensitivityCalculationKeffEOC(Burnup &bu,bool vid)
{
  // +++ Forward calculation
  Calculation(bu,true);

  med[0].CalMacroFromMicro();

  Medium med2_copy=med[2];
  if(vid){
    for(int i=0;i<med[2].GetNucnum();i++){
      int mat=med[2].GetNuclideInTurn(i).GetMatnum();
      real den=med[2].GetNuclideInTurn(i).GetDensity();
      if(mat==10010||mat==80160)den*=0.9;
      med2_copy.GetNuclideInTurn(i).PutDensity(den);
    };
    med2_copy.CalMacroFromMicro();
  };

  // +++ EOC calculation
  GeneralOption opt,opta;
  opta.PutAdjointCal();

  PJISystem lata(group,3);
  lata.PutTrajectorySet(&sys_f);
  lata.AddMedium(med[0]);
  lata.AddMedium(med[1]);
  lata.AddMedium(med2_copy);
  lata.PutRegMed(region_medium);
  lata.PutGeneralOption(opta);
  lata.PutSigmaCol(sigtr);
  lata.PutPij();
  real k_adj=lata.CalIgenPij();

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med2_copy);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  real k_fwd=lat.CalIgenPij();

  // (Direct term)
  // (Sensitivity only for HM is calculated)
  int nucnum=0;
  int nnmax=med[0].GetNucnum();
  int *nucid=new int[nnmax];
  for(int i=0;i<med[0].GetNucnum();i++){
    int id=med[0].GetNuclideInTurn(i).GetMatnum();
    real den=med[0].GetNuclideInTurn(i).GetDensity();
    if(id>=900000&&den>0.){
      //if((id>=900000||(id>=620000&&id<630000))&&den>0.){
      nucid[nucnum++]=id;
    };
  };
  SensitivityData sens=lata.CalSensitivityNew(&lat,k_fwd,nucnum,nucid);
  delete [] nucid;
  sens.PutName("burner_pincell","k_EOC","unknown");
  if(vid){
    sens.WriteFile("./","sns.k_vid_EOC_dir");
  }else{
    sens.WriteFile("./","sns.k_EOC_dir");
  };

  int sub_step=sub_step_list[burn_step-1];
  // (initialization for final condition)
  for(int i=0;i<nucn;i++){
    adj_nuc_e[burn_step-1][sub_step-1].put_data(i,0.);
  };

  for(int i=0;i<nucn;i++){
    real org=med[0].GetNuclideInTurn(i).GetDensity();
    lat.GetMedium(0).GetNuclideInTurn(i).PutDensity(org*1.01);
    lat.GetMedium(0).CalMacroFromMicro();
    real dk=lata.CalReactivity(&lat,k_adj,k_fwd,false)*k_adj*k_fwd;
    lat.GetMedium(0)=med[0];
    //int mmt=med[0].GetNuclideInTurn(i).GetMatnum();
    //cout<<mmt<<" "<<midt.Name(mmt)<<" "<<dk*100.<<"\n";
    real src=0.;
    if(org!=0.)src=dk/(org*0.01);
    adj_nuc_e[burn_step-1][sub_step-1].put_data(i,src);
  };
  //exit(0);

  cout<<"# Sensitivity calculation for Keff EOC\n";
  AdjointBurnupCalculation(bu);
  AveragingForwardNumberDensity();
  SensitivityData sens2;
  if(vid){
    SensitivityPrinting(bu,k_fwd,"burner_pincell","k_EOC","unknown","k_vid_EOC_indir");
    sens2.ReadFile("./","sns.k_vid_EOC_indir");
    sens.AddSensitivityData(sens2);
    sens.WriteFile("./","sns.k_vid_EOC");
  }else{
    SensitivityPrinting(bu,k_fwd,"burner_pincell","k_EOC","unknown","k_EOC_indir");
    sens2.ReadFile("./","sns.k_EOC_indir");
    sens.AddSensitivityData(sens2);
    sens.WriteFile("./","sns.k_EOC");
  };


};

void Burner::SensitivityCalculationRRREOC(Burnup &bu,int nume_nuc,int *nume_id,enum xstype *nume_xs,int denom_nuc,int *denom_id,enum xstype *denom_xs,bool *on_mesh)
{
  // +++ Forward calculation
  Calculation(bu,true);

  med[0].CalMacroFromMicro();

  // +++ EOC calculation
  GeneralOption opt,opta;
  opta.PutAdjointCal();

  PJISystem lat(group,3);
  lat.PutTrajectorySet(&sys_f);
  lat.AddMedium(med[0]);
  lat.AddMedium(med[1]);
  lat.AddMedium(med[2]);
  lat.PutRegMed(region_medium);
  lat.PutGeneralOption(opt);
  lat.PutSigmaCol(sigtr);
  lat.PutPij();
  real keff=lat.CalIgenPij();

  PJISystem lata(group,3);
  lata.PutTrajectorySet(&sys_f);
  lata.AddMedium(med[0]);
  lata.AddMedium(med[1]);
  lata.AddMedium(med[2]);
  lata.PutRegMed(region_medium);
  lata.PutGeneralOption(opta);
  lata.PutSigmaCol(sigtr);
  lata.PutPij();
  lata.PutPL(0); // PJI uses PutPL method in the "CalIgen" method.

  real nume=lat.CalMacroscopicReactionRate(nume_nuc,nume_id,nume_xs,on_mesh);
  real denom=lat.CalMacroscopicReactionRate(denom_nuc,denom_id,denom_xs,on_mesh);
  real rrr=nume/denom;

  // (Direct term)
  // (Sensitivity only for HM is calculated)
  int nucnum=0;
  int nnmax=med[0].GetNucnum();
  int *nucid=new int[nnmax];
  for(int i=0;i<med[0].GetNucnum();i++){
    int id=med[0].GetNuclideInTurn(i).GetMatnum();
    real den=med[0].GetNuclideInTurn(i).GetDensity();
    if(id>=900000&&den>0.){
      nucid[nucnum++]=id;
    };
  };
  SensitivityData sens=lata.CalSensitivityRRR(lat,nume_nuc,nume_id,nume_xs,denom_nuc,denom_id,denom_xs,on_mesh,nucnum,nucid,keff);
  delete [] nucid;
  sens.PutName("burner_pincell","RRR_EOC","unknown");
  sens.WriteFile("./","sns.RRR_EOC_dir");

  int sub_step=sub_step_list[burn_step-1];
  // (initialization for final condition)
  for(int i=0;i<nucn;i++){
    adj_nuc_e[burn_step-1][sub_step-1].put_data(i,0.);
  };

  // +++ Initial adjoint number density calculation
  for(int i=0;i<nucn;i++){
    real org=med[0].GetNuclideInTurn(i).GetDensity();
    lat.GetMedium(0).GetNuclideInTurn(i).PutDensity(org*1.01);
    // (indirect term calculation)
    lat.GetMedium(0).CalMacroFromMicro();
    real dr=lata.CalReactivity(&lat,keff,keff,false,false)*rrr;
    // (direct term calculation)
    real nume=lat.CalMacroscopicReactionRate(nume_nuc,nume_id,nume_xs,on_mesh);
    real denom=lat.CalMacroscopicReactionRate(denom_nuc,denom_id,denom_xs,on_mesh);
    real rrr_pert=nume/denom;
    dr+=(rrr_pert-rrr);
    //
    lat.GetMedium(0)=med[0];
    //int mmt=med[0].GetNuclideInTurn(i).GetMatnum();
    //cout<<mmt<<" "<<midt.Name(mmt)<<" "<<rrr<<" "<<dr<<"\n";
    real src=0.;
    if(org!=0.)src=dr/(org*0.01);
    adj_nuc_e[burn_step-1][sub_step-1].put_data(i,src);
  };
  //exit(0);

  cout<<"# Sensitivity calculation for RRR EOC\n";
  AdjointBurnupCalculation(bu);
  AveragingForwardNumberDensity();
  SensitivityPrinting(bu,rrr,"burner_pincell","RRR_EOC","unknown","RRR_EOC_indir");
};

void Burner::SetArrayForSensitivityCalculation()
{
  fwd_nuc.resize(burn_step);
  dmdf_nuc.resize(burn_step);  // (dM/dphi) * (NUC_FWD)
  macxs.resize(burn_step);
  mic_sigf.resize(burn_step);
  mic_sigc.resize(burn_step);
  volflx_mesh.resize(burn_step);
  adj_nuc.resize(burn_step);
  adj_nuc_e.resize(burn_step);
  adj_nuc_s.resize(burn_step);
  pow_adj.resize(burn_step);
  gpt_flx.resize(burn_step);

  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    fwd_nuc[i].resize(sub_step+1);
    dmdf_nuc[i].resize(sub_step+1);
    volflx_mesh[i].resize(mesh_fuel);
    macxs[i].Init("MacroCrossSection");
    mic_sigf[i].resize(nucn);
    mic_sigc[i].resize(nucn);
    adj_nuc[i].resize(sub_step);
    adj_nuc_e[i].resize(sub_step);
    adj_nuc_s[i].resize(sub_step);
    pow_adj[i].resize(sub_step+1);
    gpt_flx[i].resize(sub_step);
    for(int j=0;j<sub_step;j++){
      gpt_flx[i][j].resize(mesh_fuel);
      for(int ii=0;ii<mesh_fuel;ii++){
        gpt_flx[i][j][ii].put_imax(group);
      };
      adj_nuc[i][j].put_imax(nucn);
      adj_nuc_e[i][j].put_imax(nucn);
      adj_nuc_s[i][j].put_imax(nucn);
    };
    for(int j=0;j<sub_step+1;j++){
      fwd_nuc[i][j].put_imax(nucn);
      dmdf_nuc[i][j].resize(group);
    };
  };
};

void Burner::AdjointBurnupCalculation(Burnup &bu)
{
  GeneralOption opt,opta;
  opta.PutAdjointCal();

  PJISystem lat_gpt(group,3);
  lat_gpt.NoPrint();
  lat_gpt.PutTrajectorySet(&sys_f);
  lat_gpt.AddMedium(med[0]);
  lat_gpt.AddMedium(med[1]);
  lat_gpt.AddMedium(med[2]);
  lat_gpt.PutRegMed(region_medium);
  lat_gpt.PutGeneralOption(opt);
  lat_gpt.PutSigmaCol(sigtr);
  lat_gpt.PutBuckling(0.);
  lat_gpt.WriteProcOff();

  GroupData1D gpt_src(group);  // positive
  GroupData1D gpt_src2(group); // negative

  real fuel_vol_inv=1./fuel_vol;

  // (sub-sub-time step division)
  int ssv=40;

  // (Adjoint burnup calculation)
  for(int st=burn_step-1;st>=0;st--){

    real power_density=power_density_list[st];
    int sub_step=sub_step_list[st];

    lat_gpt.GetMed(0).GetMacxs().DataCopy(macxs[st]);
    lat_gpt.PutPij();
    real keff_step=lat_gpt.CalIgenPij();

    for(int i=0;i<nucn;i++){
      int id=med[0].GetNuclideInTurn(i).GetMatnum();
      bu.PutNuclideData(i,id,0.,xsf_1g[st][i],xsc_1g[st][i],xsn2n_1g[st][i]);
    };
    bu.CalTransitionMatrixFluxDependentPart();
    GroupData2D trmat_flxdep=bu.GetTrmatFlxDep();

    for(int j=sub_step-1;j>=0;j--){

      // +++ Adjoint nuclide density calculation
      GroupData2D mmat1=trmat_flxdep*(total_flux[st][j]*1e-24);
      GroupData2D mmat2=trmat_flxindep+mmat1;
      mmat2.Transposition();
      GroupData1D ttt2=adj_nuc_e[st][j];
      real dts=0.;

      // OLD
      /*          
      adj_nuc[st][j].set_zero();
      real delta_t=delt[st][j]/ssv;
      mmat2=mmat2.CalMatrixExponentialByChebyshev14(delta_t);
      mmat2.ReducedForm();
      for(int k=0;k<ssv;k++){
        GroupData1D ttt=mmat2*ttt2;
        adj_nuc[st][j]=adj_nuc[st][j]+(ttt2+ttt)*(0.5/ssv);
        ttt2=ttt;
      };
      adj_nuc_s[st][j]=ttt2; 
      */

      // NEW
      
      adj_nuc[st][j]=ttt2*(0.5/ssv);
      vector<GroupData1D> ans(ssv);
      mmat2.MultiStepCalc(ttt2,ans,delt[st][j],ssv);
      for(int k=0;k<ssv-1;k++){
        adj_nuc[st][j]=adj_nuc[st][j]+ans[k]/ssv;
      };
      adj_nuc[st][j]=adj_nuc[st][j]+ans[ssv-1]*(0.5/ssv);
      adj_nuc_s[st][j]=ans[ssv-1];
      

      // +++ Adjoint power calculation 
      real factor=1./power_density;
      if(power_density==0.)factor=1e10;
      pow_adj[st][j]=adj_nuc[st][j]*(mmat1*(fwd_nuc[st][j+1]+fwd_nuc[st][j]))*0.5*delt[st][j]*factor;

      // +++ Generalized adjoint flux calculation
      // (source calculation)
      for(int g=0;g<group;g++){
	real tmp=0.;
	// (power term)
	for(int k=0;k<nucn;k++){
	  if(nuclide_info[k]==1){
            int id=med[0].GetNuclideInTurn(k).GetMatnum();
    	    tmp+=mic_sigf[st][k].get_dat(g)*fwd_nuc[st][j].get_dat(k)
                *bu.GetReactionEnergyData().GetFissionEnergy(id);
	  };
	};
	tmp*=pow_adj[st][j];
  	// (number density term)
        tmp-=(adj_nuc[st][j]*(dmdf_nuc[st][j][g]+dmdf_nuc[st][j+1][g]))*0.5*delt[st][j]*fuel_vol_inv;
	if(tmp>0.){
          gpt_src.put_data(g,tmp);
          gpt_src2.put_data(g,0.);
	}else{
          gpt_src.put_data(g,0.);
          gpt_src2.put_data(g,-tmp);
	};
      };

      // Orthgolality check
      /*
      real sum=0.;
      real sump=0.;
      real sumn=0.;
      for(int g=0;g<group;g++){
        sum+=fuel_flux[st].get_dat(g)*(gpt_src.get_dat(g)-gpt_src2.get_dat(g));
        sump+=fuel_flux[st].get_dat(g)*gpt_src.get_dat(g);
        sumn+=fuel_flux[st].get_dat(g)*gpt_src2.get_dat(g);
      };
      cout<<" Phi * Q : "<<sum<<" "<<sump<<" "<<sumn<<"\n";
      */
      GroupData1D newnuc=adj_nuc_s[st][j];

      if(power_density>1e-5){

	lat_gpt.PutGeneralOption(opta);
        
	// (positive source)
        lat_gpt.SetZeroScatSrc();
	for(int m=0;m<mesh_fuel;m++){
          lat_gpt.PutIsotropicSourcePerUnitVolume(m,gpt_src);
	};
	lat_gpt.CalGPT(keff_step,1e-4,10);
	for(int rr=0;rr<mesh_fuel;rr++){
	  gpt_flx[st][j][rr]=lat_gpt.GetMesh(rr).GetFlux();
	};

	// (negative source)
        lat_gpt.SetZeroScatSrc();
	for(int m=0;m<mesh_fuel;m++){
          lat_gpt.PutIsotropicSourcePerUnitVolume(m,gpt_src2);
	};
	lat_gpt.CalGPT(keff_step,1e-4,10);
	for(int rr=0;rr<mesh_fuel;rr++){
	  gpt_flx[st][j][rr]=gpt_flx[st][j][rr]-lat_gpt.GetMesh(rr).GetFlux();
	};

        // (Jump condition)
	//   (n,2n) reaction is neglected since scattering matrix is required.
        for(int k=0;k<nucn;k++){
          real xsf1g=xsf_1g[st][k];
	  // (power term)
          real tmp1=0.;
	  if(xsf1g>0.){
            int id=med[0].GetNuclideInTurn(k).GetMatnum();
            tmp1=xsf1g*total_flux[st][j]*fuel_vol
                *bu.GetReactionEnergyData().GetFissionEnergy(id)*pow_adj[st][j];
	  };
          // (absorption term)
          real tmp2=0.;
          if(nuclide_info[k]!=0){
  	    for(int g=0;g<group;g++){
  	      real xsa=mic_sigc[st][k].get_dat(g); 
              if(xsf1g>0.)xsa+=mic_sigf[st][k].get_dat(g);
              for(int m=0;m<mesh_fuel;m++){
	        tmp2+=volflx_mesh[st][m].get_dat(g)*power_factor[st][j]
	              *gpt_flx[st][j][m].get_dat(g)*xsa;
	      };
	    };
	  };
	  // (yield term)
          real tmp3=0.;
	  if(xsf1g>0.){
	    for(int m=0;m<mesh_fuel;m++){
	      real fsrc=0.;
	      for(int g=0;g<group;g++){
		fsrc+=volflx_mesh[st][m].get_dat(g)*power_factor[st][j]*mic_sigf[st][k].get_dat(g)
   	 	     *med[0].GetNuclideInTurn(k).GetMicxs().GetData1d(nu).get_dat(g);
	      };
	      for(int g=0;g<group;g++){
		tmp3+=gpt_flx[st][j][m].get_dat(g)*fsrc*macxs[st].GetData1d(chi).get_dat(g);
	      };
	    };
	    tmp3/=keff_step;
	  };
          newnuc.add_data(k,-tmp1+tmp2-tmp3);
        };

      };

      // (adjoint number density check)
      bool zero_adj=true;
      for(int n=0;n<nucn;n++){
	if(fabs(newnuc.get_dat(n))>1e-20){
	  zero_adj=false;
	  break;
	};
      };
      if(zero_adj){
	cout<<"# Error in Burner::AdjointBurnupCalculation.\n";
	cout<<"# All adjoint number density is zero.\n";
	exit(0);
      };

      if(j!=0){
        adj_nuc_e[st][j-1]=newnuc;
      }else if(st!=0){
        int sst=sub_step_list[st-1];
        adj_nuc_e[st-1][sst-1]=newnuc;
      };

    };

  };
};

void Burner::AveragingForwardNumberDensity()
{
  // (forward nuclide density is averaged in each time sub-step)
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    for(int j=0;j<sub_step;j++){
      for(int k=0;k<nucn;k++){
	fwd_nuc[i][j].put_data(k,(fwd_nuc[i][j].get_dat(k)+fwd_nuc[i][j+1].get_dat(k))*0.5);
      };
    };
  };
};

void Burner::SensitivityPrinting(Burnup &bu,real response,string sys_name,string para_name,string lib_name,string addname)
{
  SensitivityData sns;
  sns.PutName(sys_name,para_name,lib_name);
  sns.PutValue(response);
  sns.PutGroup(group);
  sns.GetEnband().copy(med[0].GetEnband());

  real end_nuc=response;
  real en_inverse=1./end_nuc;

  GroupData1D sns1d(group);
  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    int rmax=3;
    if(matnum<900000)rmax=2;
    if(nuclide_info[i]==0)rmax=0; // no cross section data
    for(int r=0;r<rmax;r++){

      enum xstype sigxx=sigc;
      int mt=102;
      int bc_channel=1;
      if(r==1){
	sigxx=sign2n;
	mt=16;
	bc_channel=2;
      }else if(r==2){
        sigxx=sigf;
        mt=18;
        bc_channel=0;
      };

      // (pre-calculation for number density term)
      vector< vector<real> > nadj_dm_nfwd(burn_step);
      for(int k=0;k<burn_step;k++){
        int sub_step=sub_step_list[k];
        nadj_dm_nfwd[k].resize(sub_step);
        for(int l=0;l<sub_step;l++){
          real val=0.;
          val+=-fwd_nuc[k][l].get_dat(i)*adj_nuc[k][l].get_dat(i);
          int tmp=bu.GetBC().GetNdiv(matnum,bc_channel);
          for(int j=0;j<tmp;j++){
            int id2=bu.GetBC().GetNextID(matnum,bc_channel,j);
            int pos=bu.SearchNuclide(id2);
            if(pos!=-1){
              real rat=bu.GetBC().GetRatio(matnum,bc_channel,j);
              val+=adj_nuc[k][l].get_dat(pos)*rat*fwd_nuc[k][l].get_dat(i);
            };
          };
          nadj_dm_nfwd[k][l]=val*delt[k][l];
        };
      };

      for(int j=0;j<group;j++){
        real sum=0.;
        for(int k=0;k<burn_step;k++){
          int sub_step=sub_step_list[k];
          real xs=0.;
          if(r==0)xs=mic_sigc[k][i].get_dat(j);
          if(r==1)xs=xslib.GetLibData(matnum).GetXSData().GetData1d(sign2n).get_dat(j);
          if(r==2)xs=mic_sigf[k][i].get_dat(j);
          real den0=fwd_nuc[k][0].get_dat(i);
          for(int l=0;l<sub_step;l++){
            real den=fwd_nuc[k][l].get_dat(i);
            // --- Number density term
            // (dM)*(flx*1e-24) = (dsig_j*phi_j/flx)*(flx*1e-24) = dsig_j*phi_j*1e-24
            real dsig=xs*(fuel_flux[k].get_dat(j)*power_factor[k][l])*1e-24;
            sum+=dsig*nadj_dm_nfwd[k][l];
            // --- Power normalization term (fission case)
            if(sigxx==sigf){
              int iid=med[0].GetNuclideInTurn(i).GetMatnum();
              real flx=fuel_flux[k].get_dat(j)*power_factor[k][l]*fuel_vol;
              sum-=pow_adj[k][l]*flx*xs*den*bu.GetReactionEnergyData().GetFissionEnergy(iid);
            };
            // --- flux term [(n,2n) reaction is not well treated yet.]
            real nu_value=0.;
	    if(sigxx==sigf)nu_value=med[0].GetNuclideInTurn(i).GetMicxs().GetData1d(nu).get_dat(j);
            for(int m=0;m<mesh_fuel;m++){
              real tmp2=volflx_mesh[k][m].get_dat(j)*power_factor[k][l]*den0*xs;
              // (absorption)
              sum+=tmp2*gpt_flx[k][l][m].get_dat(j);
              // (yield)(only for fission case)
              if(sigxx==sigf){
                tmp2*=nu_value/keff[k];
		for(int gg=0;gg<group;gg++){
  	          sum-=tmp2*gpt_flx[k][l][m].get_dat(gg)*macxs[k].GetData1d(chi).get_dat(gg);
		};
	      };
	    };
	  };
        };
        sns1d.put_data(j,sum*en_inverse);
      };
      sns.PutSensitivity1D(matnum,mt,sns1d);
    };
  };

  // +++ For fission yield +++++++++++++++++++++++++++++++++++++++++++++++++++++
  //int idfisn=5;
  //int idfisorg[]={922350,922380,942380,942390,942410};
  int idfisn=21;//kawamoto
  int idfisorg[]={
    922340,922350,922360,922370,922380,
    932370,932390,
    942380,942390,942400,942410,942420,
    952410,952420,952421,952430,
    962420,962430,962440,962450,962460,
  };

  for(int ii=0;ii<idfisn;ii++){
    int idfis=idfisorg[ii];
    int pos0=bu.SearchNuclide(idfis);
    int nuct=bu.GetBC().GetNdivFission(idfis);
    for(int i=0;i<nuct;i++){
      int id=bu.GetBC().GetNextIDFission(idfis,i);
      real rat=bu.GetBC().GetRatioFission(idfis,i);
      int pos=bu.SearchNuclide(id);
      if(pos!=-1){
        real val=0.;
        for(int k=0;k<burn_step;k++){
          int sub_step=sub_step_list[k];
          real factor=mic_sigf[k][pos0]*fuel_flux[k]*1e-24*rat;
          for(int l=0;l<sub_step;l++){
            val+=(adj_nuc[k][l].get_dat(pos)*power_factor[k][l]*factor*fwd_nuc[k][l].get_dat(pos0))*delt[k][l];
	  };
	};
        sns.PutSensitivity0D(id,18000000+idfis,val*en_inverse);
      };
    };
  };

  // +++ For Half-life +++++++++++++++++++++++++++++++++++++++++++
  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    real decay_c=bu.GetDecayConstant(matnum);
    if(decay_c!=0.){
      decay_c*=-0.01; // dT=0.01T -> dlamba=-0.01 lambda
      real sum=0.;
      for(int k=0;k<burn_step;k++){
        int sub_step=sub_step_list[k];
        for(int l=0;l<sub_step;l++){
          real den=fwd_nuc[k][l].get_dat(i);
          real val=-decay_c*den*adj_nuc[k][l].get_dat(i);
          int tmp=bu.GetBC().GetNdivDecay(matnum);
          for(int j=0;j<tmp;j++){
            int id2=bu.GetBC().GetNextIDDecay(matnum,j);
            int pos=bu.SearchNuclide(id2);
            if(pos!=-1){
   	      real rat=bu.GetBC().GetRatioDecay(matnum,j);
	      val+=rat*decay_c*den*adj_nuc[k][l].get_dat(pos);
	    };
	  };
	  val*=delt[k][l];
	  sum+=val;
	};
      };
      sum*=100.;// because dT=0.01T
      sns.PutSensitivity0D(matnum,8888,sum*en_inverse);
    };
  };

  string filename="sns."+addname;
  sns.WriteFile("./",filename);
};

void Burner::SensitivityPrintingForDecayHeat(Burnup &bu,real response,vector<int> &nuc,vector<vector<real> > &energy_sens)
{
  string sys_name="burner_pincell";
  string para_name="decayheat";
  string lib_name="unknown";
  string addname="decayheat";

  SensitivityData sns;
  sns.PutName(sys_name,para_name,lib_name);
  sns.PutValue(response);
  sns.PutGroup(group);
  sns.GetEnband().copy(med[0].GetEnband());

  real end_nuc=response;
  real en_inverse=1./end_nuc;

  GroupData1D sns1d(group);
  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    int rmax=3;
    if(matnum<900000)rmax=2;
    if(nuclide_info[i]==0)rmax=0; // no cross section data
    for(int r=0;r<rmax;r++){

      enum xstype sigxx=sigc;
      int mt=102;
      int bc_channel=1;
      if(r==1){
	sigxx=sign2n;
	mt=16;
	bc_channel=2;
      }else if(r==2){
        sigxx=sigf;
        mt=18;
        bc_channel=0;
      };

      // (pre-calculation for number density term)
      vector< vector<real> > nadj_dm_nfwd(burn_step);
      for(int k=0;k<burn_step;k++){
        int sub_step=sub_step_list[k];
        nadj_dm_nfwd[k].resize(sub_step);
        for(int l=0;l<sub_step;l++){
          real val=0.;
          val+=-fwd_nuc[k][l].get_dat(i)*adj_nuc[k][l].get_dat(i);
          int tmp=bu.GetBC().GetNdiv(matnum,bc_channel);
          for(int j=0;j<tmp;j++){
            int id2=bu.GetBC().GetNextID(matnum,bc_channel,j);
            int pos=bu.SearchNuclide(id2);
            if(pos!=-1){
              real rat=bu.GetBC().GetRatio(matnum,bc_channel,j);
              val+=adj_nuc[k][l].get_dat(pos)*rat*fwd_nuc[k][l].get_dat(i);
            };
          };
          nadj_dm_nfwd[k][l]=val*delt[k][l];
        };
      };

      for(int j=0;j<group;j++){
        real sum=0.;
        for(int k=0;k<burn_step;k++){
          int sub_step=sub_step_list[k];
          real xs=0.;
          if(r==0)xs=mic_sigc[k][i].get_dat(j);
          if(r==1)xs=xslib.GetLibData(matnum).GetXSData().GetData1d(sign2n).get_dat(j);
          if(r==2)xs=mic_sigf[k][i].get_dat(j);
          real den0=fwd_nuc[k][0].get_dat(i);
          for(int l=0;l<sub_step;l++){
            real den=fwd_nuc[k][l].get_dat(i);
            // --- Number density term
            // (dM)*(flx*1e-24) = (dsig_j*phi_j/flx)*(flx*1e-24) = dsig_j*phi_j*1e-24
            real dsig=xs*(fuel_flux[k].get_dat(j)*power_factor[k][l])*1e-24;
            sum+=dsig*nadj_dm_nfwd[k][l];
            // --- Power normalization term (fission case)
            if(sigxx==sigf){
              int iid=med[0].GetNuclideInTurn(i).GetMatnum();
              real flx=fuel_flux[k].get_dat(j)*power_factor[k][l]*fuel_vol;
              sum-=pow_adj[k][l]*flx*xs*den*bu.GetReactionEnergyData().GetFissionEnergy(iid);
            };
            // --- flux term [(n,2n) reaction is not well treated yet.]
            real nu_value=0.;
	    if(sigxx==sigf)nu_value=med[0].GetNuclideInTurn(i).GetMicxs().GetData1d(nu).get_dat(j);
            for(int m=0;m<mesh_fuel;m++){
              real tmp2=volflx_mesh[k][m].get_dat(j)*power_factor[k][l]*den0*xs;
              // (absorption)
              sum+=tmp2*gpt_flx[k][l][m].get_dat(j);
              // (yield)(only for fission case)
              if(sigxx==sigf){
                tmp2*=nu_value/keff[k];
		for(int gg=0;gg<group;gg++){
  	          sum-=tmp2*gpt_flx[k][l][m].get_dat(gg)*macxs[k].GetData1d(chi).get_dat(gg);
		};
	      };
	    };
	  };
        };
        sns1d.put_data(j,sum*en_inverse);
      };
      sns.PutSensitivity1D(matnum,mt,sns1d);
    };
  };

  // +++ For fission yield +++++++++++++++++++++++++++++++++++++++++++++++++++++
  //int idfisn=5;
  //int idfisorg[]={922350,922380,942380,942390,942410};
  int idfisn=21;//kawamoto
  int idfisorg[]={
    922340,922350,922360,922370,922380,
    932370,932390,
    942380,942390,942400,942410,942420,
    952410,952420,952421,952430,
    962420,962430,962440,962450,962460,
  };

  for(int ii=0;ii<idfisn;ii++){
    int idfis=idfisorg[ii];
    int pos0=bu.SearchNuclide(idfis);
    int nuct=bu.GetBC().GetNdivFission(idfis);
    for(int i=0;i<nuct;i++){
      int id=bu.GetBC().GetNextIDFission(idfis,i);
      real rat=bu.GetBC().GetRatioFission(idfis,i);
      int pos=bu.SearchNuclide(id);
      if(pos!=-1){
        real val=0.;
        for(int k=0;k<burn_step;k++){
          int sub_step=sub_step_list[k];
          real factor=mic_sigf[k][pos0]*fuel_flux[k]*1e-24*rat;
          for(int l=0;l<sub_step;l++){
            val+=(adj_nuc[k][l].get_dat(pos)*power_factor[k][l]*factor*fwd_nuc[k][l].get_dat(pos0))*delt[k][l];
	  };
	};
        sns.PutSensitivity0D(id,18000000+idfis,val*en_inverse);
      };
    };
  };

  // +++ For Half-life +++++++++++++++++++++++++++++++++++++++++++
  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    real decay_c=bu.GetDecayConstant(matnum);
    if(decay_c!=0.){
      decay_c*=-0.01; // dT=0.01T -> dlamba=-0.01 lambda
      real sum=0.;
      for(int k=0;k<burn_step;k++){
        int sub_step=sub_step_list[k];
        for(int l=0;l<sub_step;l++){
          real den=fwd_nuc[k][l].get_dat(i);
          real val=-decay_c*den*adj_nuc[k][l].get_dat(i);
          int tmp=bu.GetBC().GetNdivDecay(matnum);
          for(int j=0;j<tmp;j++){
            int id2=bu.GetBC().GetNextIDDecay(matnum,j);
            int pos=bu.SearchNuclide(id2);
            if(pos!=-1){
   	      real rat=bu.GetBC().GetRatioDecay(matnum,j);
	      val+=rat*decay_c*den*adj_nuc[k][l].get_dat(pos);
	    };
	  };
	  val*=delt[k][l];
	  sum+=val;
	};
      };
      sum*=100.;// because dT=0.01T
      sum=sum*en_inverse;

      //+++Add direct sensitivity term+++
      real sns_direct=0.;
      for(int j=0;j<nuc.size();j++){
	if(nuc[j]==matnum){
	  real tmpsum=0.;
	  for(int jj=0;jj<3;jj++){
	    tmpsum+=energy_sens[j][jj];
	  };
	  sns_direct=tmpsum;
	};
      };
      sum=sum-sns_direct;
      //+++++++++++++++++++++++++++++++++

      sns.PutSensitivity0D(matnum,8888,sum);
    };
  };

  // +++ For Branching Ratio +++++++++++++++++++++++++++++++++++++++++++

  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    real decay_c=bu.GetDecayConstant(matnum);
    if(decay_c!=0.){
      int channel=bu.GetBC().GetNdivDecay(matnum);
      if(channel>1){
      vector<real> sns_tmp1;
      vector<real> ratio;
      sns_tmp1.resize(channel);
      ratio.resize(channel);
      for(int j=0;j<channel;j++){
	real sum=0.;
	real rat=bu.GetBC().GetRatioDecay(matnum,j);
	ratio[j]=rat;
	rat*=0.01;
	real time=0.;
	for(int k=0;k<burn_step;k++){
	  int sub_step=sub_step_list[k];
	  for(int l=0;l<sub_step;l++){
	    real den=fwd_nuc[k][l].get_dat(i);
	    //real den=fwd_nuc[k][l+1].get_dat(i);
	    int id2=bu.GetBC().GetNextIDDecay(matnum,j);
	    int pos=bu.SearchNuclide(id2);
	    real val=0.;
	    if(pos!=-1){
	      val+=adj_nuc[k][l].get_dat(pos)*decay_c*rat*den;
	    };
	    time+=delt[k][l];
	    val*=delt[k][l];
	    sum+=val;
	  };
	};
	sum*=100.;// because dr=0.01r
	sum=sum*en_inverse;
	sns_tmp1[j]=sum;
      };

      //Make constrained sensitivity
      vector<real> sns_tmp2;
      sns_tmp2.resize(channel);
      for(int j=0;j<channel;j++){
	real tmps=0.;
	for(int jj=0;jj<channel;jj++){
	  tmps+=sns_tmp1[jj];
	};
	sns_tmp2[j]=sns_tmp1[j]-tmps*ratio[j];
      };
      //

      for(int j=0;j<channel;j++){
	int mt=88880+j;
	sns.PutSensitivity0D(matnum,mt,sns_tmp2[j]);
      };
    };
  };
};
      
  /*      
  for(int i=0;i<nucn;i++){
    int matnum=med[0].GetNuclideInTurn(i).GetMatnum();
    real decay_c=bu.GetDecayConstant(matnum);
    if(decay_c!=0.){
      int channel=bu.GetBC().GetNdivDecay(matnum);
      if(channel>1){
	vector<real> sns_tmp1;
	vector<real> ratio;
	sns_tmp1.resize(channel);
	ratio.resize(channel);
	for(int j=0;j<channel;j++){
	  real sum=0.;
	  real rat=bu.GetBC().GetRatioDecay(matnum,j);
	  ratio[j]=rat;
	  rat*=0.01;
	  real time=0.;
	  for(int k=0;k<burn_step;k++){
	    int sub_step=sub_step_list[k];
	    for(int l=0;l<sub_step;l++){
	      real den=fwd_nuc[k][l].get_dat(i);
	      //real den=fwd_nuc[k][l+1].get_dat(i);
	      real val=0.;
	      val+=-adj_nuc[k][l].get_dat(i)*decay_c*rat*den;
	      for(int jj=0;jj<channel;jj++){
		int id2=bu.GetBC().GetNextIDDecay(matnum,jj);
		int pos=bu.SearchNuclide(id2);
		if(pos!=-1){
		  if(jj==j){
		    val+=adj_nuc[k][l].get_dat(pos)*decay_c*rat*den;
		  }else if(jj!=j){
		    val+=-adj_nuc[k][l].get_dat(pos)*decay_c*rat*den;
		  };
		};
	      };
	      //time+=delt[k][l];
	      val*=delt[k][l];
	      sum+=val;
	    };
	  };
	  sum*=100.;// because dr=0.01r
	sum=sum*en_inverse;
	sns_tmp1[j]=sum;
	if(fabs(sum)>0.1)cout<<sum<<"\n";
      };
      
      //+++Add direct sensitivity term+++

      for(int j=0;j<nuc.size();j++){
	if(nuc[j]==matnum){
	  real tmpsum=0.;
	  for(int jj=0;jj<3;jj++){
	    tmpsum+=energy_sens[j][jj];
	  };
	  for(int jjj=0;j<channel;jjj++){
	    real tmp3=sns_tmp1[jjj];
	    sns_tmp1[jjj]=tmp3+tmpsum*ratio[jjj];	 
	    if(fabs(sns_tmp1[jjj])>0.1)cout<<sns_tmp1[jjj]<<"\n";
	  };
	};
      };

      //      
      //Make constrained sensitivity

      vector<real> sns_tmp2;
      sns_tmp2.resize(channel);
      for(int j=0;j<channel;j++){
	real tmps=0.;
	for(int jj=0;jj<channel;jj++){
	  tmps+=sns_tmp1[jj];
	};
	sns_tmp2[j]=sns_tmp1[j]-tmps*ratio[j];
      };
      for(int j=0;j<channel;j++){
	sns_tmp1[j]=sns_tmp2[j];
      };

      //

      for(int j=0;j<channel;j++){
	int mt=88880+j;
	sns.PutSensitivity0D(matnum,mt,sns_tmp1[j]);
      };
    };
  };
};
*/  
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  // +++ For Decay Energy +++++++++++++++++++++++++++++++++++++++++++
  for(int i=0;i<nuc.size();i++){
    for(int j=0;j<3;j++){
      int mt=99990+j;
    sns.PutSensitivity0D(nuc[i],mt,energy_sens[i][j]);
    };
  };
  //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  string filename="sns."+addname;
  sns.WriteFile("./",filename);
};

void Burner::SensitivityRead(string filename,string prtname)
{
  int prtid=midt.ID(prtname);

  bool nucname=true;

  int maxn=10;
  int maxfis=5;

  real sens_low=1e-2;

  vector<int> target_id(maxn);

  vector< vector<int> > xssns_mat(maxn);
  vector< vector<int> > xssns_mt(maxn);
  vector< vector<GroupData1D> > xssns(maxn);

  vector< vector<int> > yldsns_fis(maxn);
  vector< vector< vector<int> > > yldsns_mat(maxn);
  vector< vector< vector<real> > > yldsns(maxn);
  for(int i=0;i<maxn;i++){
    yldsns_mat[i].resize(maxfis);
    yldsns[i].resize(maxfis);
  };

  vector< vector<int> > hlsns_mat(maxn);
  vector< vector<real> > hlsns(maxn);
  // 

  ifstream fin;
  fin.open(filename.data(),ios::in);
  if(fin.fail()){
    cout<<"Failed to open the file.\n";
    exit(0);
  };

  int target_nuc=0;

  int itmp=0;
  real tmp;
  while(itmp!=-1){
    if(target_nuc==10){
      cout<<"Error !\n";
      cout<<"Please increase maxn\n";
      exit(0);
    };

    fin>>itmp;
    if(itmp==-1)break;
    target_id[target_nuc]=itmp;

    int idflag=0;
    while(idflag!=-1){
      fin>>idflag;
      if(idflag==3){ // XS sensitivity read
        int grp;
        fin>>grp;
        int mat;
        fin>>mat;
        int mt;
        fin>>mt;
        xssns_mat[target_nuc].push_back(mat);
        xssns_mt[target_nuc].push_back(mt);
        GroupData1D dat(grp);
        for(int g=0;g<grp;g++){
	  fin>>tmp;
	  dat.put_data(g,tmp);
        };
        xssns[target_nuc].push_back(dat);
      }else if(idflag==18){
	int sz=yldsns_fis[target_nuc].size();
	if(sz==maxfis){
	  cout<<"Error !\n";
	  cout<<"Please increase maxfis.\n";
	  exit(0);
	};
	fin>>itmp;
	yldsns_fis[target_nuc].push_back(itmp);
	int inuc;
	fin>>inuc;
	for(int i=0;i<inuc;i++){
	  fin>>itmp;
	  yldsns_mat[target_nuc][sz].push_back(itmp);
	  fin>>tmp;
	  yldsns[target_nuc][sz].push_back(tmp);
	};
      }else if(idflag==88){
	int idf=0;
	while(idf!=-1){
  	  fin>>idf;
	  if(idf!=-1){
  	    fin>>tmp;
	    hlsns_mat[target_nuc].push_back(idf);
	    hlsns[target_nuc].push_back(tmp);
	  };
	};
      };
    };
    target_nuc++;
  };

  // ++++++++++++++

  int tid=-1;
  for(int i=0;i<target_nuc;i++){
    if(prtid==target_id[i])tid=i;
  };
  if(tid==-1){
    cout<<"+ No data "<<prtid<<"\n";
  };

  // +++ XS sensitivity print +++
  cout<<"\n+++ 1-group cross section sensitivity +++\n\n";
  int xs_size=xssns_mat[tid].size();
  for(int i=0;i<xs_size;i++){
    int mat=xssns_mat[tid][i];
    int mt=xssns_mt[tid][i];
    real sns1g=xssns[tid][i].get_sum();
    if(fabs(sns1g)>sens_low){
      cout.setf(ios::scientific);
      cout.precision(5);
      if(nucname){
        string tmp=midt.Name(mat);
        cout<<tmp<<" "<<mt<<" "<<sns1g<<"\n";
      }else{
        cout<<mat<<" "<<mt<<" "<<sns1g<<"\n";
      };
    };
  };

  // +++ Fission yield print +++
  cout<<"\n+++ fission yield sensitivity +++\n";
  cout<<"   (fis-nuc / FP-nuc / sens )\n\n";
  //int fy_size=yldsns_fis[tid].size()+1;
  int fy_size=yldsns_fis[tid].size();
  real sum=0.;
  for(int i=0;i<fy_size;i++){
    int fismat=yldsns_fis[tid][i];
    //int nuc=yldsns_mat[tid][i].size()+1;
    int nuc=yldsns_mat[tid][i].size();
    for(int j=0;j<nuc;j++){
      sum+=yldsns[tid][i][j];
      if(yldsns[tid][i][j]>sens_low){
	if(nucname){
          string tmp=midt.Name(fismat);
          string tmp2=midt.Name(yldsns_mat[tid][i][j]);
	  cout<<tmp<<" "<<tmp2<<" "<<yldsns[tid][i][j]<<"\n";
	}else{
  	  cout<<fismat<<" "<<yldsns_mat[tid][i][j]<<" "<<yldsns[tid][i][j]<<"\n";
	};
      };
    };
  };
  cout<<"#  (Sum) : "<<sum<<"\n\n";

  // +++ Half-life 
  cout<<"\n+++ half-life sensitivity +++\n\n";
  int hl_size=hlsns_mat[tid].size();
  for(int j=0;j<hl_size;j++){
    int mat=hlsns_mat[tid][j];
    if(hlsns[tid][j]>sens_low){
      if(nucname){
        string tmp=midt.Name(mat);
        cout<<tmp<<" "<<hlsns[tid][j]<<"\n";
      }else{
        cout<<mat<<" "<<hlsns[tid][j]<<"\n";
      };
    };
  };

};

void Burner::AddActinideDecayHeatDataToBurnupChain(string cbglibdir,string fname,Burnup &bu)
{
  cbglibdir=cbglibdir+"CBGLIB/DDfile/"+fname;

  BCGManager man;
  man.ReadDecayDataFromFile(cbglibdir);
  int iill=8;
  int ialist[]={92,94,94,94,94,95,96,96};
  int izlist[]={237,238,239,240,241,241,242,244};
  //int matno[]={9234,9434,9437,9440,9443,9543,9631,9637};
  int matno[8];
  for(int i=0;i<8;i++){
    matno[i]=ialist[i]*10000+izlist[i]*10;
  };
  for(int i=0;i<iill;i++){
    for(int j=0;j<3;j++){
      real ee=man.GetNuclide(ialist[i],izlist[i],0).GetDecayEnergy(j);
      bu.GetBurnupChain().GetNuclideChainData(matno[i]).PutDecayEnergy(j,ee);
    };
  };
};

void Burner::GetNuclideDensity(vector<string> &nuc,vector<real> &den,int step)
{
  if(step<0||step>burn_step){
    cout<<"# Error in Burner::GetNuclideDensity.\n";
    cout<<"# Chosen burnup step is inappropriate.\n";
    cout<<"# You chose the step "<<step<<"\n";
    cout<<"# Maximum step is "<<burn_step<<"\n";
    exit(0);
  };

  nuc.clear();
  den.clear();
  nuc.resize(nucn);
  den.resize(nucn);
  for(int i=0;i<nucn;i++){
    nuc[i]=midt.Name(med[0].GetNuclideInTurn(i).GetMatnum());
    den[i]=density_data[step][i];
  };
};

/*
real Burner::GetNuclideDensity(string nuc,int step)
{
  if(step<0||step>burn_step){
    cout<<"# Error in Burner::GetNuclideDensity.\n";
    cout<<"# Chosen burnup step is inappropriate.\n";
    cout<<"# You chose the step "<<step<<"\n";
    cout<<"# Maximum step is "<<burn_step<<"\n";
    exit(0);
  };

  int nucid=midt.ID(nuc);

  for(int i=0;i<nucn;i++){
    int tmp=med[0].GetNuclideInTurn(i).GetMatnum();
    if(tmp==nucid)return density_data[step][i];
  };

  cout<<"# Error in Burner::GetNuclideDensity.\n";
  cout<<"# No material in fuel region.\n";
  cout<<"# You chose the nuclide "<<nuc<<"\n";
  exit(0);
};
*/

real Burner::GetNuclideDensity(int nucid,int step)
{
  if(step<0||step>burn_step){
    cout<<"# Error in Burner::GetNuclideDensity.\n";
    cout<<"# Chosen burnup step is inappropriate.\n";
    cout<<"# You chose the step "<<step<<"\n";
    cout<<"# Maximum step is "<<burn_step<<"\n";
    exit(0);
  };

  for(int i=0;i<nucn;i++){
    int tmp=med[0].GetNuclideInTurn(i).GetMatnum();
    if(tmp==nucid)return density_data[step][i];
  };

  cout<<"# Error in Burner::GetNuclideDensity.\n";
  cout<<"# No material in fuel region.\n";
  cout<<"# You chose the nuclide : "<<nucid<<"\n";
  exit(0);
};

// +++++++++++++++++++++++++++++++++++++++++++
//
// +++++++++++++++++++++++++++++++++++++++++++

void Burner::CobaltActivationCalculation(real den_init, real flux_factor)
// (implemented in 2012/09/01, see the notebook)
{
  real half_life_co60=5.271*365*24*60*60; // (s)
  //real br_co60g=0.444; // branching ratio of Co-59 (n,g) to ground (from JEFF-3.1A)
  real br_co60g=1.; // since half-life of Co-60 meta is about 10 minutes
  real decay_e_co60=9.67734e4+2.50384e6; // (eV) from JEFF-3.1.1 decay data file
  real ev_to_j=1.60219e-19;

  real dc=0.6931471818056/half_life_co60;

  vector<real> n_co59(burn_step+1);
  vector<real> n_co60(burn_step+1);

  vector<int> bgrp(1);
  bgrp[0]=group;

  GroupData1D sigc_co59=xslib.GetLibData(270590).GetXSData().GetData1d(sigc);

  cout<<"#\n# +++ Co-60 activation calculation +++\n#\n";
  real n59=den_init;
  real n60=0.;
  for(int i=0;i<burn_step+1;i++){
    n_co59[i]=n59;
    n_co60[i]=n60;
    if(i!=burn_step){
      real sig=sigc_co59.Cond(clad_flux[i],1,bgrp).get_dat(0)*1e-24;
      if(i==0)cout<<"#   Co-59 (n,g) cross section at initial state : "<<sig*1e24<<"\n#\n";
      for(int j=0;j<sub_step_list[i];j++){
        real flx=total_flux_clad[i][j]*flux_factor;
        real dt=delt[i][j];
        real coef=br_co60g*n59*sig*flx/(dc-sig*flx);
        n59=n59*exp(-sig*flx*dt);
        n60=coef*(exp(-sig*flx*dt)-exp(-dc*dt))+n60*exp(-dc*dt);
      };
    };
  };

  cout<<"#\n# +++ Information of Co-60 in clad region +++\n";
  if(flux_factor!=1.)cout<<"#     (flux is multiplied by "<<flux_factor<<")\n";
  cout<<"# (day)   (GWd/t)   N.D.[/cm3]  N.D.[/cm]   Heat[W/cm] Heat[W/tHM] RAD[Bq/tHM]\n#\n";
  cout.setf(ios::scientific);
  cout.precision(4);
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acburn[i]<<" ";
    cout<<n_co60[i]*1e24<<" ";
    cout<<n_co60[i]*1e24*clad_vol<<" ";
    cout<<n_co60[i]*1e24*clad_vol*dc*decay_e_co60*ev_to_j<<" ";
    cout<<n_co60[i]*1e24*clad_vol*dc*decay_e_co60*ev_to_j/(hm_weight_init*1e-6)<<" ";
    cout<<n_co60[i]*1e24*clad_vol*dc/(hm_weight_init*1e-6)<<" ";
    cout<<"\n";
  };
};

void Burner::Mn54ActivationCalculation(real den_init,real flux_factor)
{
  if(group!=70&&group!=107){
    cout<<"# Error in Burner::Mn54ActivationCalculation.\n";
    cout<<"# 70- and 107-group calculations have been implemented.\n";
    cout<<"# You are calculating with "<<group<<"-group.\n";
    exit(0);
  };

  if(den_init==0.){
    if(!med[1].ExistNuclide(260000)){
      cout<<"# Mn-54 activation calculation is not performed\n";
      cout<<"# because Fe-54 is not included in clad regin.\n";
      return;
    }else{
      den_init=med[1].GetNuclide(260000).GetDensity()*0.058;// (5.8% in natural isotope)
    };
  };

  real half_life_mn54=312.05*24*60*60; // (s)
  real decay_e_mn54=8.36e5+4.03e3; // (eV) from JEFF-3.1.1 decay data file
  real ev_to_j=1.60219e-19;

  real dc=0.6931471818056/half_life_mn54;

  vector<real> n_fe54(burn_step+1);
  vector<real> n_mn54(burn_step+1);

  vector<int> bgrp(1);
  bgrp[0]=group;

  GroupData1D sigp_fe54(group);
  sigp_fe54.set_zero();
  real datinp[]={
    5.003E-01, 5.020E-01, 4.483E-01, 2.967E-01, 1.831E-01,
    7.703E-02, 1.964E-02, 2.661E-03, 3.949E-04, 1.126E-05
  }; // JENDL-4.0 multigroup data
  for(int i=0;i<10;i++){
    sigp_fe54.put_data(i,datinp[i]);
  };

  cout<<"#\n# +++ Mn-54 activation calculation +++\n#\n";
  real n0=den_init;
  real n1=0.;
  for(int i=0;i<burn_step+1;i++){
    n_fe54[i]=n0;
    n_mn54[i]=n1;
    if(i!=burn_step){
      real sig=sigp_fe54.Cond(clad_flux[i],1,bgrp).get_dat(0)*1e-24;
      if(i==0)cout<<"#   Fe-54 (n,p) cross section at initial state : "<<sig*1e24<<"\n#\n";
      for(int j=0;j<sub_step_list[i];j++){
        real flx=total_flux_clad[i][j]*flux_factor;
        real dt=delt[i][j];
        real coef=n0*sig*flx/(dc-sig*flx);
        n0=n0*exp(-sig*flx*dt);
        n1=coef*(exp(-sig*flx*dt)-exp(-dc*dt))+n1*exp(-dc*dt);
      };
    };
  };

  cout<<"#\n# +++ Information of Mn-54 in clad region +++\n";
  if(flux_factor!=1.)cout<<"#     (flux is multiplied by "<<flux_factor<<")\n";
  cout<<"# (day)   (GWd/t)   N.D.[/cm3]  N.D.[/cm]   Heat[W/cm] Heat[W/tHM] RAD[Bq/tHM]\n#\n";
  cout.setf(ios::scientific);
  cout.precision(4);
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acburn[i]<<" ";
    cout<<n_mn54[i]*1e24<<" ";
    cout<<n_mn54[i]*1e24*clad_vol<<" ";
    cout<<n_mn54[i]*1e24*clad_vol*dc*decay_e_mn54*ev_to_j<<" ";
    cout<<n_mn54[i]*1e24*clad_vol*dc*decay_e_mn54*ev_to_j/(hm_weight_init*1e-6)<<" ";
    cout<<n_mn54[i]*1e24*clad_vol*dc/(hm_weight_init*1e-6)<<" ";
    cout<<"\n";
  };
};

void Burner::Reprocessing(real tc, real ru_rh, real fp, real ac)
{
  int nucnum=med[0].GetNucnum();
  for(int i=0;i<nucnum;i++){
    int mat=med[0].GetNuclideInTurn(i).GetMatnum();
    real den=med[0].GetNuclideInTurn(i).GetDensity();
    real ratio=fp;
    if(mat>=900000){
      ratio=ac;
    }else if(mat>=430000&&mat<=439999){
      ratio=tc;
    }else if(mat>=440000&&mat<=459999){
      ratio=ru_rh;
    };
    med[0].GetNuclideInTurn(i).PutDensity(den*ratio);
  };
};

void Burner::NumberDensityReset(int mat_st,int mat_ed,real den)
{
  if(mat_st>mat_ed){
    cout<<"# Error in Burner::NumberDensityReset.\n";
    cout<<"# Please check start/end points of material ID.\n";
    exit(0);
  };

  int nucnum=med[0].GetNucnum();
  for(int i=0;i<nucnum;i++){
    int mat=med[0].GetNuclideInTurn(i).GetMatnum();
    if(mat>=mat_st&&mat<=mat_ed){
      med[0].GetNuclideInTurn(i).PutDensity(den);
    };
  };
};

void Burner::NumberDensityReset(int mat,real den)
{
  if(!med[0].ExistNuclide(mat)){
    cout<<"# Error in Burner::NumberDensityReset.\n";
    cout<<"# Nuclide "<<mat<<" does NOT exist.\n";
    exit(0);
  };
  med[0].GetNuclide(mat).PutDensity(den);
};

// +++++++++++++++++++++++++++++++++++++++++++
//  LIMITED BURNUP CALCULATION
// +++++++++++++++++++++++++++++++++++++++++++

void Burner::LimitBurnupOn(real kl, int batchinp)
{
  limit_burnup=true;
  k_limit=kl;
  batch=batchinp;
};

real Burner::GetEOCBurnup(){
  if(!limit_burnup){
    cout<<"# Error in Burner::GetEOCBurnup\n";
    cout<<"# This method is effective only for limited burnup calculation.\n";
    exit(0);
  };
  return bumax;
};

real Burner::GetAtomWiseWeightAtBOC(Burnup &bu,int atm)
{
  real avo=0.60221367;

  real sum=0.;
  for(int i=0;i<nucn;i++){
    int id=med[0].GetNuclideInTurn(i).GetMatnum();
    if(id>=atm*100&&id<(atm+1)*100){
      real dd=density_data[0][i];
      real aw=bu.GetAtomicWeight(id);
      real mol=(dd*fuel_vol)/avo;
      real wt=aw*mol*1e-3;
      sum+=wt/(hm_weight_init*1e-6);
    };
  };
  return sum;
};

real Burner::GetAtomWiseWeightAtEOC(Burnup &bu,int atm)
{
  real avo=0.60221367;

  real bu0=acburn[burn_step-1];
  real bu1=acburn[burn_step];

  real sum=0.;
  for(int i=0;i<nucn;i++){
    int id=med[0].GetNuclideInTurn(i).GetMatnum();
    if(id>=atm*100&&id<(atm+1)*100){
      real dd0=density_data[burn_step-1][i];
      real dd1=density_data[burn_step][i];
      real dd=dd0+(dd1-dd0)/(bu1-bu0)*(bumax-bu0);
      real aw=bu.GetAtomicWeight(id);
      real mol=(dd*fuel_vol)/avo;
      real wt=aw*mol*1e-3;
      sum+=wt/(hm_weight_init*1e-6);
    };
  };
  return sum;
};

// +++++++++++++++++++++++++++++++++++++++++++
//  Lumped FP creation
// +++++++++++++++++++++++++++++++++++++++++++

void Burner::CreatePseudoFP(Burnup &bu,string fissle_name,int nucnum,string *nucname,int outid,string outname)
{
  int fisid=midt.ID(fissle_name);
  
  vector<real> sc(group,0.);
  int fpnum=bu.GetBurnupChain().GetNdivFission(fisid);

  vector<int> nucid(nucnum);
  for(int i=0;i<nucnum;i++){
    nucid[i]=midt.ID(nucname[i]);
  };

  real sum=0.;
  for(int i=0;i<fpnum;i++){
    int fpid=bu.GetBurnupChain().GetNextIDFission(fisid,i);
    real fprat=bu.GetBurnupChain().GetRatioFission(fisid,i);
    bool same=false;
    for(int j=0;j<nucnum;j++){
      if(fpid==nucid[j])same=true;
    };
    if(!same){
      real dc=bu.GetBurnupChain().GetDecayConstant(fpid);
      real hl=0.;
      if(dc>0.)hl=0.693/dc;
      if(xslib.GetLibData(fpid).GetMat()!=-1){
	//if(xslib.GetLibData(fpid).GetMat()!=-1){
	//if(xslib.GetLibData(fpid).GetMat()!=-1&&(hl==0.||hl>60*60*24*10)){
        for(int g=0;g<group;g++){
  	  real sigval=xslib.GetLibData(fpid).GetXSData().GetData1d(sigc).get_dat(g);
	  sc[g]+=sigval*fprat;
        };
        sum+=fprat;
      };
    };
  };

  sum=1./sum;
  for(int g=0;g<group;g++){
    sc[g]*=sum;
  };

  LibData pfp;
  pfp.PutGroup(group);
  pfp.PutMat(outid);
  for(int g=0;g<group;g++){
    pfp.GetXSData().GetData1d(sigc).put_data(g,sc[g]);
    pfp.GetXSData().GetData1d(sigt).put_data(g,sc[g]);
    //cout<<xslib.GetEnband().get_dat(g)<<" "<<sc[g]<<"\n";
  };

  pfp.GetFtable().PutNomtft(0);
  pfp.GetFtable().PutNsig0(0);
  pfp.GetFtable().PutMaxtemp(0);
  pfp.GetFtable().PutMaxnr(0);
  pfp.WriteFile("./",outname);

};

void Burner::LFP(Burnup &bu,string fissle_name,int nucnum,string *nucname)
{
  int fisid=midt.ID(fissle_name);
  
  vector<real> sc(group,0.);
  int fpnum=bu.GetBurnupChain().GetNdivFission(fisid);

  vector<int> nucid(nucnum);
  for(int i=0;i<nucnum;i++){
    nucid[i]=midt.ID(nucname[i]);
  };

  real sum=0.;
  for(int i=0;i<fpnum;i++){
    int fpid=bu.GetBurnupChain().GetNextIDFission(fisid,i);
    real fprat=bu.GetBurnupChain().GetRatioFission(fisid,i);
    bool same=false;
    for(int j=0;j<nucnum;j++){
      if(fpid==nucid[j])same=true;
    };
    if(!same){
      if(xslib.GetLibData(fpid).GetMat()!=-1){
        for(int g=0;g<group;g++){
  	  real sigval=xslib.GetLibData(fpid).GetXSData().GetData1d(sigc).get_dat(g);
	  sc[g]+=sigval*fprat;
        };
      };
      sum+=fprat;
    };
  };

  sum=1./sum;
  for(int g=0;g<group;g++){
    sc[g]*=sum;
  };

  LibData pfp;
  pfp.PutGroup(group);
  pfp.PutMat(9999);
  for(int g=0;g<group;g++){
    pfp.GetXSData().GetData1d(sigc).put_data(g,sc[g]);
    pfp.GetXSData().GetData1d(sigt).put_data(g,sc[g]);
  };
  pfp.GetFtable().PutNomtft(0);
  pfp.GetFtable().PutNsig0(0);
  pfp.GetFtable().PutMaxtemp(0);
  pfp.GetFtable().PutMaxnr(0);
  pfp.WriteFile("./","pfp");

  /*
  // (judging from relative error in all/some groups)
  real errmax=1e10;
  int eid=-1;
  for(int i=0;i<fpnum;i++){
    int fpid=bu.GetBurnupChain().GetNextIDFission(fisid,i);
    if(xslib.GetLibData(fpid).GetMat()!=-1){
      real errsum=0.;
      real errmax2=0.;
      for(int g=0;g<group;g++){
	//for(int g=59;g<group;g++){ // (below 3.9279eV)
        real err=fabs(xslib.GetLibData(fpid).GetXSData().GetData1d(sigc).get_dat(g)/sc[g]-1.);
	errsum=err*err;
	if(errsum>errmax2)errmax2=errsum;
      };
      if(errsum<errmax){
	errmax=errsum;
	eid=fpid;
      };

    };
  };
  */
  
  // (judging from thermal capture)
  /*
  real errmax=1e10;
  int eid=-1;
  for(int i=0;i<fpnum;i++){
    int fpid=bu.GetBurnupChain().GetNextIDFission(fisid,i);
    if(xslib.GetLibData(fpid).GetMat()!=-1){
      int g=98;
      real err=fabs(xslib.GetLibData(fpid).GetXSData().GetData1d(sigc).get_dat(g)-sc[g]);
      if(err<errmax){
	errmax=err;
	eid=fpid;
      };
    };
  };
  */

  /*
  cout<<"# Candidate is "<<midt.Name(eid)<<"\n";
  for(int g=0;g<group;g++){
    real e=xslib.GetEnband().get_dat(g);
    cout<<e<<" "<<sc[g]<<" ";
    real xs=xslib.GetLibData(eid).GetXSData().GetData1d(sigc).get_dat(g);
    cout<<xs<<"\n";
  };
  */
};

void Burner::ShowPseudoFPCrossSection(Burnup &bu,int nucnum,string *nucname)
{
  vector<int> nucid(nucnum);
  for(int i=0;i<nucnum;i++){
    nucid[i]=midt.ID(nucname[i]);
  };

  vector< vector<real> > cont(burn_step+1);
  vector<real> contsum(burn_step+1,0.);

  cout<<"################################################\n";
  cout<<"# Cross sections of non-important FP nuclides. #\n";
  cout<<"################################################\n";

  for(int i=1;i<=burn_step;i++){

    cout<<"# Step   : "<<i<<"\n";
    cout<<"# Burnup : "<<acburn[i]<<" [GWd/t]\n";

    cont[i].resize(nucn);
    vector<real> sc(group,0.);
    real sum=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      bool same=false;
      for(int k=0;k<nucnum;k++){
        if(id==nucid[k])same=true;
      };
      if(!same){
	if(xslib.ExistLibData(id)&&id<900000&&id>=100000){
	  real den=density_data[i][j];
	  real tmp=den*xslib.GetLibData(id).GetXSData().GetData1d(sigc).get_dat(99);
	  cont[i][j]=tmp;
	  contsum[i]+=tmp;
	  for(int g=0;g<group;g++){
	    real sigval=xslib.GetLibData(id).GetXSData().GetData1d(sigc).get_dat(g);
	    sc[g]+=sigval*den;
	  };
	  sum+=den;
	};
      };
    };
 
    if(sum!=0)sum=1./sum;
    for(int g=0;g<group;g++){
      sc[g]*=sum;
    };

    cout<<"\n\n# [Averaged-microscopic cross section]\n";
    // cross section printing
    for(int g=0;g<group;g++){
      cout.setf(ios::scientific);
      cout.precision(5);
      real e=xslib.GetEnband().get_dat(g);
      cout<<e<<" "<<sc[g]<<"\n";
    };
    cout<<"\n\n";

  };

  // contribution printing for group 100
  cout<<" Nuc ";
  for(int i=1;i<burn_step;i++){
    cout<<acburn[i]<<" ";
  };
  cout<<"\n";

  for(int j=0;j<nucn;j++){
    int id=med[0].GetNuclideInTurn(j).GetMatnum();
    bool same=false;
    for(int k=0;k<nucnum;k++){
      if(id==nucid[k])same=true;
    };
    if(!same){
      if(xslib.ExistLibData(id)&&id<900000&&id>99999){
	bool large=false;
	for(int i=1;i<burn_step;i++){
          if(cont[i][j]/contsum[i]>0.01)large=true;
 	};
	if(large){
          cout<<midt.Name(id)<<" ";
	  for(int i=1;i<burn_step;i++){
	    cout<<cont[i][j]/contsum[i]<<" ";
	  };
    	  cout<<"\n";
	};
      };
    };
  };
};

// +++++++++++++++++++++++++++++++++++++++++++
//  OUTPUT EDITING
// +++++++++++++++++++++++++++++++++++++++++++

/*
void Burner::ShowDecayHeat(Burnup &bu,bool detail_print,real factor)
{
  cout.setf(ios::scientific);
  cout.precision(4);
  cout<<"#\n# Time-dependent decay heat (day, W/cm , W/tHM";
  if(detail_print)cout<<", ([HM][FP])";
  cout<<")\n";
  if(factor!=1.){
    cout<<"#     factorized by "<<factor<<"\n";
  };
  cout<<"#\n";
  real ev_to_j=1.60219e-19;
  ev_to_j*=factor;
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" ";
    real en=0.;
    real en_hm=0.;
    real en_fp=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      real den=density_data[i][j]*1e24;
      real lambda=bu.GetDecayConstant(id);
      real e=0.;
      for(int k=0;k<3;k++){
        e+=bu.GetBurnupChain().GetDecayEnergy(id,k);
      };
      real enuc=e*(den*fuel_vol)*lambda;
      en+=enuc;
      if(id>=900000){en_hm+=enuc;}else{en_fp+=enuc;};
    };
    en*=ev_to_j; // J
    en_hm*=ev_to_j; 
    en_fp*=ev_to_j;
    cout<<en<<" ";
    if(detail_print){
      cout<<"( "<<en_hm<<" ";
      cout<<en_fp<<" ) ";
    };
    cout<<en/(hm_weight_init*1e-6)<<" "; // J/tHM
    if(detail_print){
      cout<<"( "<<en_hm/(hm_weight_init*1e-6)<<" ";
      cout<<en_fp/(hm_weight_init*1e-6)<<" ) ";
    };
    cout<<"\n";
  };

};
*/

 /*
void Burner::ShowRadioactivity(Burnup &bu,bool detail_print,real factor)
{
  cout.setf(ios::scientific);
  cout.precision(4);
  cout<<"#\n# Time-dependent radioactivity (day, year, Bq/cm , Bq/tHM";
  if(detail_print)cout<<", ([HM][FP])";
  cout<<")\n";
  if(factor!=1.){
    cout<<"#     factorized by "<<factor<<"\n";
  };
  cout<<"#\n";
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acday[i]/365.<<" ";
    real en=0.;
    real en_hm=0.;
    real en_fp=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      real den=density_data[i][j]*1e24;
      real lambda=bu.GetDecayConstant(id);
      real enuc=(den*fuel_vol)*lambda;
      en+=enuc;
      if(id>=900000){en_hm+=enuc;}else{en_fp+=enuc;};
    };
    cout<<en<<" ";
    if(detail_print){
      cout<<"  "<<en_hm<<" ";
      cout<<en_fp<<"   ";
    };
    cout<<en/(hm_weight_init*1e-6)<<" "; // Bq/tHM
    if(detail_print){
      cout<<" "<<en_hm/(hm_weight_init*1e-6)<<" ";
      cout<<en_fp/(hm_weight_init*1e-6)<<"  ";
    };
    cout<<"\n";
  };

};
*/
  /*
void Burner::ShowDecayHeatAtomWise(Burnup &bu,string nucname,real factor)
{
  int z=midt.AtomicNumberFromName(nucname);
  cout.setf(ios::scientific);
  cout.precision(4);
  cout<<"#\n# Time-dependent decay heat of "<<nucname<<" (day, W/cm , W/tHM,)\n";
  if(factor!=1.){
    cout<<"#     factorized by "<<factor<<"\n";
  };
  
  real ev_to_j=1.60219e-19*factor;
  
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" ";
    real en=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      int nucz=(int)id/10000;
      if(nucz==z){
	real den=density_data[i][j]*1e24;
	real lambda=bu.GetDecayConstant(id);
	real e=0.;
	for(int k=0;k<3;k++){
	  e+=bu.GetBurnupChain().GetDecayEnergy(id,k);
	};
	real enuc=e*(den*fuel_vol)*lambda;
	en+=enuc;
      };
    };
    en*=ev_to_j; // J
    cout<<en<<" ";
    cout<<en/(hm_weight_init*1e-6); // J/tHM
    cout<<"\n";
  };
};
  */

void Burner::GetPrintNuclide(int prt_nuc,string *prt_nuc_nam,vector<int> &prt_nuc_turn)
{
  for(int i=0;i<prt_nuc;i++){
    int id=midt.ID(prt_nuc_nam[i]);
    for(int j=0;j<nucn;j++){
      if(med[0].GetNuclideInTurn(j).GetMatnum()==id){
	prt_nuc_turn[i]=j;
	break;
      };
    };
    if(prt_nuc_turn[i]==-1){
      cout<<"# Error in Burner::GetPrintNuclide.\n";
      cout<<"# Nuclide "<<prt_nuc_nam[i]<<" is NOT included in the burnup chain.\n";
      exit(0);
    };
  };
};

void Burner::ShowEigenvalue()
{
  // (for conversion ratio calculation)
  int fert_num=5;
  int fert_mat[]={902320,922340,922380,942400,-912330};
  int fiss_num=4;
  int fiss_mat[]={922330,922350,942390,942410};

  cout<<"#\n# +++ Time-dependent eigenvalue +++\n";
  cout<<"#  (day)       ";
  cout<<"(GWd/t)     ";
  cout<<"(keff)      ";
  cout<<"(C.R.)      ";
  cout<<"(flux[/cm2/s])";
  cout<<"\n";
  cout.setf(ios::scientific);
  cout.precision(5);
  for(int i=0;i<burn_step+1;i++){
    if(i<10)cout<<" ";
    cout<<i<<" "<<acday[i]<<" "<<acburn[i]<<" "<<keff[i]<<" ";
    // (conversion ratio)
    real fert_cap=0.;
    for(int j=0;j<fert_num;j++){
      int mat=abs(fert_mat[j]);
      for(int k=0;k<nucn;k++){
	if(med[0].GetNuclideInTurn(k).GetMatnum()==mat){
  	  real factor=1.;
	  if(fert_mat[j]<0)factor=-1.;
          fert_cap+=density_data[i][k]*xsc_1g[i][k]*factor;
	};
      };
    };
    real fiss_abs=0.;
    for(int j=0;j<fiss_num;j++){
      int mat=abs(fiss_mat[j]);
      for(int k=0;k<nucn;k++){
	if(med[0].GetNuclideInTurn(k).GetMatnum()==mat){
  	  real factor=1.;
	  if(fiss_mat[j]<0)factor=-1.;
          fiss_abs+=density_data[i][k]*(xsc_1g[i][k]+xsf_1g[i][k]+xsn2n_1g[i][k])*factor;
	};
      };
    };
    cout<<fert_cap/fiss_abs<<" ";
    //
    if(i!=burn_step)cout<<total_flux[i][0]<<" ";
    cout<<"\n";
  };
};

void Burner::ShowNeutronFluxHistory()
{
  cout<<"#\n# +++ Time-dependent neutron flux [/cm2/s] +++\n";
  cout<<"# (day)       (GWd/t)     (fuel)      (clad)\n";
  cout.setf(ios::scientific);
  cout.precision(10);
  for(int i=0;i<burn_step;i++){
    cout<<i<<" "<<acday[i]<<" "<<acburn[i]<<" ";
    cout<<total_flux[i][0]<<" ";
    cout<<total_flux_clad[i][0]<<" ";
    cout<<"\n";
  };
};

void Burner::ShowNumberDensityChange(real limit)
{
  cout<<"#\n#+++ Number density before/after burnup +++\n#\n";
  cout.setf(ios::scientific);
  cout.precision(7);
  for(int ii=0;ii<2;ii++){
  for(int i=0;i<nucn;i++){
    real den_b=density_data[0][i];
    real den_a=density_data[burn_step][i];
    int matno=med[0].GetNuclideInTurn(i).GetMatnum();
    if(((ii==0&&matno>=900000)||(ii==1&&matno<900000))&&(den_a>limit||den_b>limit)){
      cout<<"# "<<matno<<" "<<midt.Name(matno)<<"   "<<den_b<<"   "<<den_a<<"\n";
      //cout<<"   "<<den_b<<"   "<<den_a<<"  "<<den_a*(xsc_1g[burn_step][i]+xsf_1g[burn_step][i])<<"\n";
      //cout<<den_a<<"\n";
    };
  };
  };
};

void Burner::ShowWeightChange(Burnup &bu, real limit)
{
  real avo=0.60221367;

  cout<<"#\n#+++ Weight before/after burnup [g/cm] +++\n#\n";
  cout.setf(ios::scientific);
  cout.precision(5);
  real sum_hm_a=0.;
  real sum_hm_b=0.;
  real sum_fp_a=0.;
  real sum_fp_b=0.;
  for(int ii=0;ii<2;ii++){
    for(int i=0;i<nucn;i++){
      real den_b=density_data[0][i];
      real den_a=density_data[burn_step][i];
      int matno=med[0].GetNuclideInTurn(i).GetMatnum();
      if(((ii==0&&matno>=900000)||(ii==1&&matno<900000))&&(den_a>limit||den_b>limit)){
	real aw=bu.GetAtomicWeight(matno);
        real wgt_b=den_b*fuel_vol/avo*aw;
        real wgt_a=den_a*fuel_vol/avo*aw;
	if(matno>=900000){
	  sum_hm_a+=wgt_a;
	  sum_hm_b+=wgt_b;
	}else if(matno>=300000){
	  sum_fp_a+=wgt_a;
	  sum_fp_b+=wgt_b;
	};
        cout<<"# "<<matno<<" "<<midt.Name(matno);
        cout<<"   "<<wgt_b<<"   "<<wgt_a<<"\n";
      };
    };
  };
  cout<<"#\n";
  cout<<"# Total weight of heavy metal     (IZ>=90)    : "<<sum_hm_b<<" "<<sum_hm_a<<"\n";
  cout<<"# Total weight of fission product (90>IZ>=30) : "<<sum_fp_b<<" "<<sum_fp_a<<"\n";
};

void Burner::ShowNumberDensityChange(int nucnum, string *nuclist)
{
  cout<<"#\n#+++ Number density before/after burnup +++\n#\n";
  cout.setf(ios::scientific);
  cout.precision(7);
  for(int ii=0;ii<2;ii++){
  for(int i=0;i<nucn;i++){
    int matno=med[0].GetNuclideInTurn(i).GetMatnum();
    for(int j=0;j<nucnum;j++){
      if(matno==midt.ID(nuclist[j])){
        real den_b=density_data[0][i];
        real den_a=density_data[burn_step][i];
        if(((ii==0&&matno>=900000)||(ii==1&&matno<900000))&&(den_a!=0.||den_b!=0.)){
          cout<<" "<<midt.Name(matno)<<"   "<<den_b<<"   "<<den_a<<"\n";
          //cout<<" "<<den_a<<"\n";
	};
      };
    };
  };
  };
};

void Burner::ShowCrossSection(int step)
{
  cout<<"#\n# One-group cross section list (cap/fis/n2n/[sum])\n#\n";
  cout<<"#   burnup-step : "<<step<<"\n#\n";
  cout<<"#\n#       ";
  cout<<"[CAPTURE]   ";   
  cout<<"[FISSION]   ";   
  cout<<"[(N,2N)]    ";   
  cout<<"[ALL]\n";
  cout.setf(ios::scientific);
  cout.precision(4);
  for(int ii=0;ii<2;ii++){
  for(int i=0;i<nucn;i++){
    int matno=med[0].GetNuclideInTurn(i).GetMatnum();
    if((ii==0&&matno>=900000)||(ii==1&&matno<900000)){
      string tmp=midt.Name(matno);
      cout<<tmp;
      for(int k=0;k<8-tmp.size();k++){cout<<" ";};
      cout<<xsc_1g[step][i]<<"  ";
      cout<<xsf_1g[step][i]<<"  ";
      cout<<xsn2n_1g[step][i]<<"  ";
      cout<<xsc_1g[step][i]+xsf_1g[step][i]+xsn2n_1g[step][i]<<"  ";
      cout<<"\n";
    };
  };
  };
};

void Burner::ShowCrossSection(int prt_nuc,string *prt_nuc_nam)
{
  vector<int> prt_nuc_turn(prt_nuc);
  GetPrintNuclide(prt_nuc,prt_nuc_nam,prt_nuc_turn);

  cout.setf(ios::scientific);
  cout.precision(4);
  for(int ii=0;ii<3;ii++){
    cout<<"#\n# One-group ";
    if(ii==0){
      cout<<"CAPTURE";
    }else if(ii==1){
      cout<<"FISSION";
    }else{
      cout<<"(N,2N)";
    };
    cout<<" cross section\n#\n";
    cout<<"#\n#(day)     (GWd/t)    ";    
    for(int j=0;j<prt_nuc;j++){
      cout<<prt_nuc_nam[j];
      int tmp=prt_nuc_nam[j].size();
      for(int k=0;k<11-tmp;k++){cout<<" ";};
    };
    cout<<"\n";
    for(int i=0;i<burn_step+1;i++){
      cout<<acday[i]<<" "<<acburn[i]<<" ";
      for(int j=0;j<prt_nuc;j++){
        real val=0.;
        if(ii==0){
          val=xsc_1g[i][prt_nuc_turn[j]];
	}else if(ii==1){
          val=xsf_1g[i][prt_nuc_turn[j]];
	}else{
          val=xsn2n_1g[i][prt_nuc_turn[j]];
	};
	cout<<val<<" ";
      };
      cout<<"\n";
    };
  };

};

void Burner::ShowCaptureToDecayRatio(int prt_nuc,string *prt_nuc_nam,Burnup &bu)
{
  cout<<"#\n# [Microscopic capture reaction rate]/[Decay constant]\n#\n";

  vector<int> prt_nuc_turn(prt_nuc);
  GetPrintNuclide(prt_nuc,prt_nuc_nam,prt_nuc_turn);

  vector<real> dc(prt_nuc);
  for(int i=0;i<prt_nuc;i++){
    dc[i]=bu.GetBurnupChain().GetDecayConstant(midt.ID(prt_nuc_nam[i]));
    if(dc[i]==0.){
      cout<<"# Warning in Burner::ShowCaptureToDecayRatio.\n";
      cout<<"# Decay constant is zero : "<<prt_nuc_nam[i]<<"\n";
      return;
    };
  };

  cout<<"#(day)     (GWd/t)    ";
  for(int j=0;j<prt_nuc;j++){
    cout<<prt_nuc_nam[j];
    int tmp=prt_nuc_nam[j].size();
    for(int k=0;k<11-tmp;k++){cout<<" ";};
  };
  cout<<"\n";

  cout.setf(ios::scientific);
  cout.precision(4);
  for(int i=0;i<burn_step;i++){
    cout<<acday[i]<<" "<<acburn[i]<<" ";
    for(int j=0;j<prt_nuc;j++){
      cout<<xsc_1g[i][prt_nuc_turn[j]]*1e-24*total_flux[i][0]/dc[j]<<" ";
    };
    cout<<"\n";
  };
};

void Burner::ShowFuelNeutronFlux(int st,bool excel)
{
  if(st>burn_step){
    cout<<"# Error in Burner::ShowFuelNeutronFlux\n";
    exit(0);
  };

  cout<<"#\n# Neutron flux per lethargy\n#\n";
  cout<<"#   burnup step : "<<st<<"\n";
  cout<<"#\n";
  if(excel){
    cout<<"# Eenrgy      Fuel          Clad\n";
    cout<<"# [eV]        region        region\n";
  }else{
    cout<<"# Upper       Fuel          Clad\n";
    cout<<"# energy[eV]  region        region\n";
  };

  cout.setf(ios::scientific);
  cout.precision(5);
  for(int i=0;i<group;i++){
    real e0=med[0].GetEnband().get_dat(i);
    real e1=med[0].GetEnband().get_dat(i+1);
    real letwid=log(e0/e1);
    cout<<e0<<"   "<<fuel_flux[st].get_dat(i)/letwid<<"   ";
    cout<<clad_flux[st].get_dat(i)/letwid<<"\n";
    if(excel){
      cout<<e1<<"   "<<fuel_flux[st].get_dat(i)/letwid<<"   ";
      cout<<clad_flux[st].get_dat(i)/letwid<<"\n";
    };
  };
};

void Burner::ShowAdjointNumberDensity(int prt_nuc,string *prt_nuc_nam)
{
  if(!adj_nuc_data){
    cout<<"# Warning in Burner::ShowAdjointNumberDensity.\n";
    cout<<"# Adjoint number density is not calculated.\n";
    return;
  };

  cout<<"# Time step-averaged adjoint number density\n";

  vector<int> prt_nuc_turn(prt_nuc,-1);
  GetPrintNuclide(prt_nuc,prt_nuc_nam,prt_nuc_turn);
  cout.setf(ios::scientific);
  cout.precision(5);

  /*
  cout<<"# COARSE time mesh\n";
  cout<<"#  ";
  for(int k=0;k<prt_nuc;k++){
    cout<<prt_nuc_nam[k]<<" ";
  };
  cout<<"\n";
  for(int i=0;i<burn_step;i++){
    cout<<i<<" ";
    for(int k=0;k<prt_nuc;k++){
      cout<<adj_nuc[i][0].get_dat(prt_nuc_turn[k])<<" ";
    };
    cout<<"\n";
  };

  cout<<"#\n# FINE time mesh\n";
  */

  cout<<"#  ";
  for(int k=0;k<prt_nuc;k++){
    cout<<prt_nuc_nam[k]<<" ";
  };
  cout<<"\n";
  for(int i=0;i<burn_step;i++){
    int sub_step=sub_step_list[i];
    for(int j=0;j<sub_step;j++){
      cout<<i<<" "<<j<<" ";
      for(int k=0;k<prt_nuc;k++){
	cout<<adj_nuc[i][j].get_dat(prt_nuc_turn[k])<<" ";
      };
      cout<<"\n";
    };
  };
};

void Burner::ShowNumberDensityHistoryAtomWise(string atom_name,Burnup &bu,string opt,bool sum_only)
{
  int sz=atom_name.size();

  vector<string> prt_nuc_nam_org;
  for(int i=0;i<nucn;i++){
    string name=midt.Name(med[0].GetNuclideInTurn(i).GetMatnum());
    int leng=name.size();
    string endchr=name.substr(leng-1,1);
    if(endchr=="M"||endchr=="m")leng--;
    leng-=3;
    if(name.substr(0,sz)==atom_name&&sz==leng)prt_nuc_nam_org.push_back(name);
  };

  int prt_nuc=prt_nuc_nam_org.size();
  string *prt_nuc_nam=new string[prt_nuc];
  for(int i=0;i<prt_nuc;i++){
    prt_nuc_nam[i]=prt_nuc_nam_org[i];
  };

  if(sum_only)cout<<"#\n# Atom-wise information : "<<atom_name<<"\n";
  ShowNumberDensityHistory(prt_nuc,prt_nuc_nam,bu,opt,sum_only);
  cout<<"\n\n";

  delete [] prt_nuc_nam;
};

void Burner::ShowNumberDensityHistoryOld(int prt_nuc,string *prt_nuc_nam,Burnup &bu,string opt,bool sum_only)
{
  real avo=0.60221367;
  real ev_to_j=1.60219e-19;

  vector<int> prt_nuc_turn(prt_nuc,-1);
  vector<int> prt_nuc_id(prt_nuc);
  for(int i=0;i<prt_nuc;i++){
    prt_nuc_id[i]=midt.ID(prt_nuc_nam[i]);
  };
  GetPrintNuclide(prt_nuc,prt_nuc_nam,prt_nuc_turn);

  cout<<"#\n#(day)     (GWd/t)      ";    
  if(opt=="nd_per_vol"){
    cout<<"N.D. [1e24/cm3]\n";
  }else if(opt=="nd"){
    cout<<"N.D. [1e24])\n";
  }else if(opt=="bq"){
    cout<<"Radioactivity [Bq]\n";
  }else if(opt=="bq_per_thm"){
    cout<<"Radioactivity [Bq/tHM]\n";
  }else if(opt=="kg_per_thm"){
    cout<<"Weight [kg/tHM]\n";
  }else if(opt=="w_per_thm"){
    cout<<"Heat [W/tHM]\n";
  };
  cout<<"#                       ";
  cout.setf(ios::scientific);
  cout.precision(4);
  if(!sum_only){
  for(int j=0;j<prt_nuc;j++){
    cout<<prt_nuc_nam[j];
    int tmp=prt_nuc_nam[j].size();
    for(int k=0;k<11-tmp;k++){cout<<" ";};
  };
  };
  cout<<" (sum)\n";
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acburn[i]<<"   ";
    real sum=0.;
    for(int j=0;j<prt_nuc;j++){
      real dd=density_data[i][prt_nuc_turn[j]];
      real dc=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[j]);
      real val=0.;
      if(opt=="nd_per_vol"){
        val=dd;
      }else if(opt=="nd"){
        val=dd*fuel_vol;
      }else if(opt=="bq"){
        val=dd*fuel_vol*dc*1e24;
      }else if(opt=="bq_per_thm"){
        val=dd*fuel_vol*dc*1e24/(hm_weight_init*1e-6);
      }else if(opt=="kg_per_thm"){
        real aw=bu.GetAtomicWeight(prt_nuc_id[j]);
	real mol=(dd*fuel_vol)/avo;
        real wt=aw*mol*1e-3;
	val=wt/(hm_weight_init*1e-6);
      }else if(opt=="w_per_thm"){
        real e=0.;
        for(int k=0;k<3;k++){
          e+=bu.GetBurnupChain().GetDecayEnergy(prt_nuc_id[j],k);
        };
        val=e*dd*1e24*fuel_vol*dc*ev_to_j/(hm_weight_init*1e-6);
      };
      if(!sum_only)cout<<val<<" ";
      sum+=val;
    };
    cout<<"  "<<sum<<"\n";
  };
};

void Burner::ShowNumberDensityHistory(int prt_nuc,string *prt_nuc_nam,Burnup &bu,string opt,bool sum_only)
{
  //int sz=density_data.size();
  //cout<<sz<<"\n"; exit(0);

  real avo=0.60221367;
  real ev_to_j=1.60219e-19;

  vector< vector<int> > each_nuc_turn(prt_nuc);
  for(int i=0;i<prt_nuc;i++){
    if(prt_nuc_nam[i]=="HM"){
      for(int j=0;j<nucn;j++){
	int matid=med[0].GetNuclideInTurn(j).GetMatnum();
	if(matid>=900000){
	  each_nuc_turn[i].push_back(j);          
	};
      };
    }else if(prt_nuc_nam[i]=="FP"){
      for(int j=0;j<nucn;j++){
	int matid=med[0].GetNuclideInTurn(j).GetMatnum();
	if(matid<900000&&matid>=310000){
	  each_nuc_turn[i].push_back(j);          
	};
      };
    }else if(prt_nuc_nam[i]=="ALL"||prt_nuc_nam[i]=="All"){
      for(int j=0;j<nucn;j++){
        each_nuc_turn[i].push_back(j);          
      };
    }else{
      int sz=prt_nuc_nam[i].size();
      if(sz<=2){
	// (atom-wise)
        for(int j=0;j<nucn;j++){
          string name=midt.Name(med[0].GetNuclideInTurn(j).GetMatnum());
          int leng=name.size();
          string endchr=name.substr(leng-1,1);
          if(endchr=="M"||endchr=="m")leng--;
          leng-=3;
          if(name.substr(0,sz)==prt_nuc_nam[i]&&sz==leng)each_nuc_turn[i].push_back(j);
        };
      }else{
	// (nuclide-wise)
	for(int j=0;j<nucn;j++){
          string name=midt.Name(med[0].GetNuclideInTurn(j).GetMatnum());
	  if(name==prt_nuc_nam[i])each_nuc_turn[i].push_back(j);
	};
      };
    };
  };

  cout<<"#\n#(day)     (GWd/t)      ";    
  if(opt=="nd_per_vol"){
    cout<<"N.D. [1e24/cm3]\n";
  }else if(opt=="nd"){
    cout<<"N.D. [1e24])\n";
  }else if(opt=="bq"){
    cout<<"Radioactivity [Bq]\n";
  }else if(opt=="bq_per_thm"){
    cout<<"Radioactivity [Bq/tHM]\n";
  }else if(opt=="kg_per_thm"){
    cout<<"Weight [kg/tHM]\n";
  }else if(opt=="w_per_thm"){
    cout<<"Heat [W/tHM]\n";
  };
  cout<<"#                       ";
  cout.setf(ios::scientific);
  cout.precision(4);
  //cout.precision(10);
  if(!sum_only){
  for(int j=0;j<prt_nuc;j++){
    cout<<prt_nuc_nam[j];
    int tmp=prt_nuc_nam[j].size();
    for(int k=0;k<11-tmp;k++){cout<<" ";};
  };
  };
  cout<<"  (sum)\n";
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acburn[i]<<"   ";
    real sum=0.;
    for(int j=0;j<prt_nuc;j++){
      int sz=each_nuc_turn[j].size();
      real val=0.;
      for(int k=0;k<sz;k++){
        int tt=each_nuc_turn[j][k];
        int id=med[0].GetNuclideInTurn(tt).GetMatnum();
        real dd=density_data[i][tt];
        real dc=bu.GetBurnupChain().GetDecayConstant(id);
        if(opt=="nd_per_vol"){
          val+=dd;
        }else if(opt=="nd"){
          val+=dd*fuel_vol;
        }else if(opt=="bq"){
          val+=dd*fuel_vol*dc*1e24;
        }else if(opt=="bq_per_thm"){
          val+=dd*fuel_vol*dc*1e24/(hm_weight_init*1e-6);
        }else if(opt=="kg_per_thm"){
          real aw=bu.GetAtomicWeight(id); 
    	  real mol=(dd*fuel_vol)/avo;
          real wt=aw*mol*1e-3;
	  val+=wt/(hm_weight_init*1e-6);
        }else if(opt=="w_per_thm"){
          real e=0.;
          for(int k=0;k<3;k++){
            e+=bu.GetBurnupChain().GetDecayEnergy(id,k);
          };
          val+=e*dd*1e24*fuel_vol*dc*ev_to_j/(hm_weight_init*1e-6);
        };
      };
      if(!sum_only)cout<<val<<" ";
      sum+=val;
    };
    cout<<"  "<<sum<<"\n";
  };
};

void Burner::ShowRadioactivityRatio(Burnup &bu,string nuc1,string nuc2)
{
  string *prt_nuc_nam=new string[2];
  prt_nuc_nam[0]=nuc1;
  prt_nuc_nam[1]=nuc2;
  vector<int> prt_nuc_turn(2,-1);
  vector<int> prt_nuc_id(2);
  prt_nuc_id[0]=midt.ID(nuc1);
  prt_nuc_id[1]=midt.ID(nuc2);
  GetPrintNuclide(2,prt_nuc_nam,prt_nuc_turn);

  delete [] prt_nuc_nam;

  int idt1=prt_nuc_turn[0];
  int idt2=prt_nuc_turn[1];

  cout<<"#\n#(day)     (GWd/t)      (Bq-ratio : "<<nuc1<<"/"<<nuc2<<")\n#\n";    
  cout.setf(ios::scientific);
  cout.precision(4);
  for(int i=0;i<burn_step+1;i++){
    real dd1=density_data[i][idt1];
    real dd2=density_data[i][idt2];
    real dc1=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[0]);
    real dc2=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[1]);
    if(dd2>0.){
      real val=(dd1*dc1)/(dd2*dc2);
      cout<<acday[i]<<" "<<acburn[i]<<"   ";
      cout<<val<<"\n";
    };
  };
};

real Burner::GetRadioactivityRatio(Burnup &bu,string nuc1,string nuc2)
{
  string *prt_nuc_nam=new string[2];
  prt_nuc_nam[0]=nuc1;
  prt_nuc_nam[1]=nuc2;
  vector<int> prt_nuc_turn(2,-1);
  vector<int> prt_nuc_id(2);
  prt_nuc_id[0]=midt.ID(nuc1);
  prt_nuc_id[1]=midt.ID(nuc2);
  GetPrintNuclide(2,prt_nuc_nam,prt_nuc_turn);

  delete [] prt_nuc_nam;

  int idt1=prt_nuc_turn[0];
  int idt2=prt_nuc_turn[1];

  int i=burn_step;
  real dd1=density_data[i][idt1];
  real dd2=density_data[i][idt2];
  real dc1=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[0]);
  real dc2=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[1]);
  return  (dd1*dc1)/(dd2*dc2);
};

real Burner::GetRadioactivity(Burnup &bu,string nuc1)
{
  string *prt_nuc_nam=new string[1];
  prt_nuc_nam[0]=nuc1;
  vector<int> prt_nuc_turn(1,-1);
  vector<int> prt_nuc_id(1);
  prt_nuc_id[0]=midt.ID(nuc1);
  GetPrintNuclide(1,prt_nuc_nam,prt_nuc_turn);
  delete [] prt_nuc_nam;

  int idt1=prt_nuc_turn[0];
  int i=burn_step;
  real dd1=density_data[i][idt1];
  real dc1=bu.GetBurnupChain().GetDecayConstant(prt_nuc_id[0]);
  return  dd1*dc1;
};

void Burner::ShowHeavyMetalWeightRatio(Burnup &bu)
{
  real avo=0.60221367;

  int nucnam_u=3;
  int nucnam_tru=1+5+3+5;
  int nucnam=nucnam_u+nucnam_tru;
  string hm_name[]={
    "U235","U236","U238",
    "Np237",
    "Pu238","Pu239","Pu240","Pu241","Pu242",
    "Am241","Am242m","Am243",
    "Cm242","Cm243","Cm244","Cm245","Cm246"
  };
  int p9_pos=5;

  vector<int> prt_nuc_turn(nucnam);
  vector<int> prt_nuc_id(nucnam);
  for(int i=0;i<nucnam;i++){
    int id=midt.ID(hm_name[i]);
    prt_nuc_id[i]=id;
    for(int j=0;j<nucn;j++){
      if(med[0].GetNuclideInTurn(j).GetMatnum()==id){
	prt_nuc_turn[i]=j;
	break;
      };
    };
  };

  vector<real> wgt(nucnam);
  cout<<"#\n# Heavy metal weight [g/cm]\n";
  cout<<"#    (before / after burnup)\n#\n";
  cout.setf(ios::scientific);
  cout.precision(5);
  real sum_b=0.;
  real sum_a=0.;
  real sumfp_b=0.;
  real sumfp_a=0.;
  real del_p9=0.;
  real sum=0.;
  for(int i=0;i<nucnam;i++){
    real aw=bu.GetAtomicWeight(prt_nuc_id[i]);
    cout<<hm_name[i]<<" ";
    real wgt_b=density_data[0][prt_nuc_turn[i]]*fuel_vol/avo*aw;
    real wgt_a=density_data[burn_step][prt_nuc_turn[i]]*fuel_vol/avo*aw;
    wgt[i]=wgt_a;
    sum_b+=wgt_b;
    sum_a+=wgt_a;
    sumfp_b+=wgt_b;
    sumfp_a+=wgt_a;
    if(i>=nucnam_u)sum+=wgt_a;
    if(i==p9_pos)del_p9=wgt_b-wgt_a;
    cout<<wgt_b<<" "<<wgt_a<<" ";
    cout<<"\n";
  };
  cout<<"(Sum)   "<<sum_b<<" "<<sum_a<<"\n";

  cout.setf(ios::showpoint);
  cout.precision(5);
  cout<<"#\n# TRU concentration [wt%]\n";
  cout<<"#   (left  : numerical result)\n";
  cout<<"#   (right : Pu-239 is added to preserve Pu-239 inventory)\n#\n";
  for(int i=nucnam_u;i<nucnam;i++){
    cout<<hm_name[i]<<"  "<<wgt[i]/sum*100<<" ";
    if(i!=p9_pos){
      cout<<wgt[i]/(sum+del_p9)*100<<" ";
    }else{
      cout<<(wgt[i]+del_p9)/(sum+del_p9)*100<<" ";
    };
    cout<<"\n";
  };

};

void Burner::ShowNuclideWiseContributionForFission(int prt_nuc,string *prt_nuc_nam)
{
  vector<int> prt_nuc_turn(prt_nuc,-1);
  vector<int> prt_nuc_id(prt_nuc);
  for(int i=0;i<prt_nuc;i++){
    prt_nuc_id[i]=midt.ID(prt_nuc_nam[i]);
  };
  GetPrintNuclide(prt_nuc,prt_nuc_nam,prt_nuc_turn);

  vector<real> fis(prt_nuc);

  cout<<"#\n";
  cout<<"# Time dependent nuclide-wise contribution to fission reaction\n";
  cout<<"#\n#(day)    (GWd/t)   ";    
  for(int j=0;j<prt_nuc;j++){
    cout<<prt_nuc_nam[j]<<" ";
    int tmp=prt_nuc_nam[j].size();
    for(int k=0;k<9-tmp;k++){cout<<" ";};
  };
  cout<<" (sum)\n";

  cout.setf(ios::scientific);
  cout.precision(3);
  for(int i=0;i<burn_step+1;i++){
    cout<<acday[i]<<" "<<acburn[i]<<" ";
    for(int j=0;j<prt_nuc;j++){
      fis[j]=0.;
    };
    real tot=0.;
    real totp=0.;
    for(int j=0;j<nucn;j++){
      real rrf=xsf_1g[i][j]*density_data[i][j];
      tot+=rrf;
      for(int k=0;k<prt_nuc;k++){
	if(prt_nuc_turn[k]==j){
          fis[k]=rrf;
	  totp+=rrf;
	};
      };
    };
    for(int j=0;j<prt_nuc;j++){
      cout<<fis[j]/tot<<" ";
    };
    cout<<" ("<<totp/tot<<")";
    cout<<"\n";
  };
};

void Burner::ShowPlutonium(Burnup &bu)
{
  real avo=0.60221367;

  cout<<"\n\n#  (day, GWd/t,   Ratio_Annihilation,  Amount_Annihilation,  Amount_Annihilation/BU,  MA-Amount\n";
  cout.setf(ios::scientific);
  cout.precision(4);

  vector<real> pu_w(burn_step+1);
  vector<real> ma_w(burn_step+1);
  for(int i=0;i<burn_step+1;i++){
    real sum=0.;
    real sum2=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      real dd=density_data[i][j];
      real val=0.;
      real aw=bu.GetAtomicWeight(id);
      real mol=(dd*fuel_vol)/avo;
      real wt=aw*mol*1e-3;
      val=wt/(hm_weight_init*1e-6);
      if(id>=940000&&id<950000){
        sum+=val;
      }else if(id>=930000){
        sum2+=val;
      };
    };
    pu_w[i]=sum;
    ma_w[i]=sum2;
  };

  for(int i=0;i<burn_step+1;i++){
    cout<<"# ";
    cout<<acday[i]<<" "<<acburn[i]<<"   ";
    real pu2=pu_w[i]-pu_w[0];
    real pu1=pu2/pu_w[0];
    real pu3=0.;
    if(acburn[i]>0.)pu3=pu2/acburn[i];
    cout<<pu1<<" "<<pu2<<" "<<pu3<<" "<<ma_w[i]<<"\n";
  };
};


void Burner::ShowMA(Burnup &bu)
{
  real avo=0.60221367;

  cout<<"\n\n#  (day, GWd/t,   Amount,  Amount/BU,  Amount/Pu_Annihilation\n";
  cout.setf(ios::scientific);
  cout.precision(4);

  vector<real> pu_w(burn_step+1);
  vector<real> ma_w(burn_step+1);
  for(int i=0;i<burn_step+1;i++){
    real sum_ma=0.;
    real sum_pu=0.;
    for(int j=0;j<nucn;j++){
      int id=med[0].GetNuclideInTurn(j).GetMatnum();
      real dd=density_data[i][j];
      real val=0.;
      real aw=bu.GetAtomicWeight(id);
      real mol=(dd*fuel_vol)/avo;
      real wt=aw*mol*1e-3;
      val=wt/(hm_weight_init*1e-6);
      if(id>=940000&&id<950000){
        sum_pu+=val;
      }else if(id>=930000){
        sum_ma+=val;
      };
    };
    pu_w[i]=sum_pu;
    ma_w[i]=sum_ma;
  };

  for(int i=0;i<burn_step+1;i++){
    cout<<"# ";
    cout<<acday[i]<<" "<<acburn[i]<<"   ";
    real ma1=ma_w[i]-ma_w[0];
    real ma2=0.;
    if(acburn[i]>0.)ma2=ma1/acburn[i];
    real ma3=0.;
    if(acburn[i]>0.)ma3=ma1/abs(pu_w[i]-pu_w[0]);
    cout<<ma1<<" "<<ma2<<" "<<ma3<<"\n";
  };
};


void Burner::ShowGroupDependentCrossSection(string nucname,bool excel)
{
  int matid=midt.ID(nucname);

  if(!med[0].ExistNuclide(matid)){
    cout<<"# Burner::ShowGroupDependentCrossSection.\n";
    cout<<"# No nuclide : "<<nucname<<"\n";
    exit(0);
  };

  cout<<"#\n# Group-dependent cross section of "<<nucname<<"\n#\n";
  if(excel){
    cout<<"# (energy)  (fission)   (capture)   (nu-value)\n"; 
  }else{
    cout<<"# (upper)   (fission)   (capture)   (nu-value)\n"; 
    cout<<"# (energy)\n";
  };
  cout.setf(ios::scientific);
  cout.precision(5);
  for(int g=0;g<group;g++){
    real e0=med[0].GetEnband().get_dat(g);
    real e1=med[0].GetEnband().get_dat(g+1);
    real fis=med[0].GetNuclide(matid).GetMicxs().GetData1d(sigf).get_dat(g);
    real cap=med[0].GetNuclide(matid).GetMicxs().GetData1d(sigc).get_dat(g);
    real vnu=xslib.GetLibData(matid).GetXSData().GetData1d(nu).get_dat(g);
    cout<<e0<<" "<<fis<<" "<<cap<<" "<<vnu<<"\n";
    if(excel)cout<<e1<<" "<<fis<<" "<<cap<<" "<<vnu<<"\n";
  };
  
};

// +++ animation

void Burner::ShowRadioactivityHistoryForAnimation(Burnup &bu)
{
  ofstream fout;
  fout.setf(ios::scientific);
  fout.precision(5);

  int graph=0; 
  int z=0;
  int a=0;
  int n=0;
  int l=0;
  int z_x=0;
  int a_x=0;
  int l_x=0;
  int z_e=0;
  int a_e=0;
  int l_e=0;
  fout.open("animation.data",ios::out);
  for(int i=0;i<nucn;i++){
    int matno=med[0].GetNuclideInTurn(i).GetMatnum();
    midt.GetParameter(matno,z,a,l);
    real dc=bu.GetBurnupChain().GetDecayConstant(matno);
    n=a-z;
    if(l==0)fout<<std::setfill('0')<<std::setw(3)<<std::right<<z<<" "<<std::setfill('0')<<std::setw(3)<<std::right<<n<<" ";
    for(int j=0;j<burn_step+1;j++){
      if(l==0){
	real rad=density_data[j][i]*fuel_vol*dc*1e24;
	for(int k=1;k<3;k++){
	  for(int p=0;p<nucn;p++){
	    int matno_x=med[0].GetNuclideInTurn(p).GetMatnum();
	    midt.GetParameter(matno_x,z_x,a_x,l_x);
	    if(l_x==k&&z_x==z&&a_x==a)rad+=density_data[j][p]*fuel_vol*dc*1e24;
	  };
	};
	fout<<rad+1.0<<" ";
	if(i==0)graph++;
      };
    };
    if(l==0)fout<<"\n";
  };
  for(int ii=1;ii<101;ii++){
    for(int jj=1;jj<161;jj++){
      for(int kk=0;kk<nucn;kk++){
	int matno_e=med[0].GetNuclideInTurn(kk).GetMatnum();
	midt.GetParameter(matno_e,z_e,a_e,l_e);
	if(z_e==ii&&(a_e-z_e)==jj)goto OUT;
      };
      fout<<std::setfill('0')<<std::setw(3)<<std::right<<ii<<" "<<std::setfill('0')<<std::setw(3)<<std::right<<jj<<" ";
	for(int pp=0;pp<burn_step+1;pp++){
	  fout<<1.0<<" ";
	};
	fout<<"\n";
    OUT:;
    };
  };
  fout<<"#Graphs: "<<graph<<"\n";	
  fout.close();
  cout<<"Graphs: "<<graph<<"\n";
};

void Burner::ShowDataForAnimation(Burnup &bu,string filename,string type)
{
  int zmin=92;
  int nmin=141;
  int zmax=96;
  int nmax=150;

  int z,a,l;

  ofstream fout;
  fout.open(filename.data(),ios::out);
  real minv=1e30;
  real maxv=0.;
  for(int st=0;st<burn_step+1;st++){

    vector< vector<real> > dat(zmax+1,vector<real>(nmax+1,0.));
    for(int i=0;i<nucn;i++){
      int matno=med[0].GetNuclideInTurn(i).GetMatnum();
      real dc=bu.GetBurnupChain().GetDecayConstant(matno);
      midt.GetParameter(matno,z,a,l);
      int n=a-z;
      if(z<=zmax&&n<=nmax){
      real tmp=0.;
      if(type=="nd"){
        tmp=density_data[st][i];
      }else if(type=="bq"){
        tmp=density_data[st][i]*dc;
      }else if(type=="w"||type=="en"){
        real e=0.;
	for(int k=0;k<3;k++){
          e+=bu.GetBurnupChain().GetDecayEnergy(matno,k);
	};
	tmp=density_data[st][i]*dc*e;
      };
      dat[z][n]+=tmp;
      };
    };


    for(int i=nmin;i<=nmax;i++){
      for(int jj=0;jj<2;jj++){
        for(int j=zmin;j<=zmax;j++){
          real tmp=dat[j][i];
          if(tmp>maxv)maxv=tmp;
	  if(tmp<minv&&tmp>0.)minv=tmp;
          fout<<i-0.5+jj<<" "<<j-0.5<<" "<<tmp<<"\n";
          fout<<i-0.5+jj<<" "<<j+0.5<<" "<<tmp<<"\n";
        };
        fout<<"\n";
      };
    };
    fout<<"\n\n";

  };

  cout<<"# step : "<<burn_step+1<<"\n";
  cout<<"# max. : "<<maxv<<"\n";
  cout<<"# min. : "<<minv<<"\n";

  fout.close();
};

void Burner::ShowDataForAnimationNew(Burnup &bu,string filename,string type)
{
  int zmin=92;
  int zmax=96;
  int amin=234;
  int amax=246;

  int z,a,l;

  ofstream fout;
  fout.open(filename.data(),ios::out);
  real minv=1e30;
  real maxv=0.;
  for(int st=0;st<burn_step+1;st++){

    vector< vector<real> > dat(zmax+1,vector<real>(amax+1,0.));
    for(int i=0;i<nucn;i++){
      int matno=med[0].GetNuclideInTurn(i).GetMatnum();
      real dc=bu.GetBurnupChain().GetDecayConstant(matno);
      midt.GetParameter(matno,z,a,l);
      if(z<=zmax&&a<=amax){
      real tmp=0.;
      if(type=="nd"){
        tmp=density_data[st][i];
      }else if(type=="bq"){
        tmp=density_data[st][i]*dc;
      }else if(type=="w"||type=="en"){
        real e=0.;
	for(int k=0;k<3;k++){
          e+=bu.GetBurnupChain().GetDecayEnergy(matno,k);
	};
	tmp=density_data[st][i]*dc*e;
      };
      dat[z][a]+=tmp;
      };
    };


    for(int i=amin;i<=amax;i++){
      for(int jj=0;jj<2;jj++){
        for(int j=zmin;j<=zmax;j++){
          real tmp=dat[j][i];
          if(tmp>maxv)maxv=tmp;
	  if(tmp<minv&&tmp>0.)minv=tmp;
          fout<<i-0.5+jj<<" "<<j-0.5<<" "<<tmp<<"\n";
          fout<<i-0.5+jj<<" "<<j+0.5<<" "<<tmp<<"\n";
        };
        fout<<"\n";
      };
    };
    fout<<"\n\n";

  };

  cout<<"# step : "<<burn_step+1<<"\n";
  cout<<"# max. : "<<maxv<<"\n";
  cout<<"# min. : "<<minv<<"\n";

  fout.close();
};

